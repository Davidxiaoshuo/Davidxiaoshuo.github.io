<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/android/jni_logger/"/>
      <url>/android/jni_logger/</url>
      
        <content type="html"><![CDATA[<h1 id="android-jni-层-log-输出">Android JNI 层 Log 输出</h1><h3 id="概述：">概述：</h3><p>android 中在进行一些 C++ 底层库开发的时候难免需要一些 log 来辅助我们的开发调试，或是打印一些重要信息给到 Lib 库的使用者。在 android 中，通过 C++ 层的 <code>print</code>  Or <code>std::cout</code> 是无法在logcat 中正常显示 log 信息的。android NDK 专门提供了相关的 <a href="https://developer.android.com/ndk/reference/group/logging" target="_blank" rel="noopener">Logging</a> 工具。</p><h3 id="android-log-print-主要使用的函数">__android_log_print 主要使用的函数</h3><pre><code class="language-c++">int __android_log_print(  int prio,//优先级  const char *tag,//标签  const char *fmt,  // format log string  ...)</code></pre><h3 id="cmake-编译-在-cmakelists-txt-中配置需要依赖的-log-系统库">cmake 编译， 在 <code>CMakeLists.txt</code> 中配置需要依赖的 Log 系统库</h3><pre><code>#指定要生成的动态库所依赖的库（系统库，外部第三方库）target_link_libraries( # Specifies the target library.                       # Links the target library to the log library                       # included in the NDK.                                              ${log-lib} )</code></pre><h3 id="通过对-android-log-print-稍加修改-来使-log-输出变得更加简单">通过对 __android_log_print 稍加修改，来使 log 输出变得更加简单</h3><blockquote><p><strong>首先要引入所需的头文件</strong> <code>#include &lt;android/log.h&gt;</code></p></blockquote><pre><code class="language-c++">#include &lt;android/log.h&gt;#define TAG &quot;ProjectName&quot; // 这个是自定义的LOG的标识   #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型，在 Release 模式下禁用   #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型   #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型   #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型   #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型 </code></pre><h3 id="使用">使用</h3><pre><code class="language-c++">char* log_example_str = &quot;hello logger&quot;;LOGD(&quot;This is a log, the content is %s&quot;, log_example_str);LOGI(&quot;This is a log, the content is %s&quot;, log_example_str);LOGW(&quot;This is a log, the content is %s&quot;, log_example_str);LOGE(&quot;This is a log, the content is %s&quot;, log_example_str);LOGF(&quot;This is a log, the content is %s&quot;, log_example_str);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/menu/"/>
      <url>/menu/</url>
      
        <content type="html"><![CDATA[<ul><li>Tech<ul><li>android<ul><li><a href="/android/cmake_list">android studio cmake 编译常规设置</a></li><li><a href="/android/jni_logger">Android Jni 层 Log 输出</a></li></ul></li><li>c++<ul><li><a href="/c++/cplus_type_convert">C++ 中 基础类型转换成 char*</a></li><li><a href="/c++/macos_remote_disk_mount">macos 远程硬盘挂载</a></li><li><a href="/c++/minicom_setup">USB 转串口工具 minicom Setup</a></li></ul></li><li>git<ul><li><a href="/git/git_multi_account_manager">Git 多github（gitlab）账号管理</a></li></ul></li><li>others<ul><li><a href="/others/hello_world">Hexo Page 简单发布流程</a></li><li><a href="/others/macos_terminal_themes">MacOS Terminal 美化 【程序猿推荐】</a></li></ul></li></ul></li><li>Life</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/c++/minicom_setup/"/>
      <url>/c++/minicom_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="usb-转串口工具-minicom-setup">USB 转串口工具 minicom Setup</h1><h3 id="准备工作">准备工作</h3><ol><li>安装 minicom 串口调试工具, 通过 Homebrew 安装即可</li></ol><pre><code class="language-bash">brew install minicom</code></pre><h3 id="setup">Setup</h3><ol><li>将串口线连接到电脑USB上，查看当前命令行查看连接的串口号</li></ol><pre><code class="language-bash">ls /dev/tty*</code></pre><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/blog_source/master/resources/images/serial_port_num.jpg" alt></p><blockquote><p><strong><em>上图中的 <code>/dev/tty.usbserial-14340</code> 就是 USB 的串口号</em></strong></p></blockquote><ol start="2"><li>将串口号配置给串口工具 <code>minicom</code></li></ol><ul><li>命令打开串口工具</li></ul><pre><code class="language-bash">minicom -s</code></pre><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/blog_source/master/resources/images/minicom_board.jpg" alt></p><ul><li>通过键盘上的 <code>J</code>, <code>K</code> 或者方向键上下移动到 <code>Serial port setup</code> 选项，按回车选中，进入串口设置界面</li></ul><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/blog_source/master/resources/images/minicom_setup.jpg" alt></p><ul><li>通过键盘上的大写字母 <code>A</code>  选中进入 <code>Serial Device</code> 选项，并将之前复制好的串口号粘贴在此，并按<strong><em>两次</em></strong>回车, 回到主 Setup 界面。</li><li>定位到 <code>Save setup as dfl</code> 回车并选中。</li><li>定位到 <code>Exit</code> 退出 Setup 界面到 串口命令终端中 或 定位到 <code>Exit from minicom</code> 退回到系统命令界面</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/c++/macos_remote_disk_mount/"/>
      <url>/c++/macos_remote_disk_mount/</url>
      
        <content type="html"><![CDATA[<h1 id="macos-远程硬盘挂载">macos 远程硬盘挂载</h1><h3 id="准备工作">准备工作</h3><ol><li>安装Homebrew, 具体安装方式，见<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">官网</a></li><li>通过Homebrew 安装 sshfs 的依赖 <code>fuse</code></li></ol><pre><code class="language-bash">brew install Caskroom/cask/osxfuse</code></pre><ol start="3"><li>通过Homebrew 安装sshfs</li></ol><pre><code class="language-bash">brew install sshfs</code></pre><h3 id="使用">使用</h3><pre><code class="language-bash">sshfs remote_account@ip:remote_directory /local/directory</code></pre><blockquote><p><strong>挂载到本地时，避免挂在到根目录下或者当前账户的主目录下，否则会引起以下错误：</strong></p></blockquote><pre><code>mount_osxfuse: mount point /Users/xxxx/ImageFolder is itself on a OSXFUSE volumefuse: failed to mount file system: Invalid argument</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/home/"/>
      <url>/home/</url>
      
        <content type="html"><![CDATA[<h2 id="home-page">Home Page</h2><p>Hi, 这里是我记录我所感兴趣的技术，生活的地方。如果技术上有错误的地方欢迎联系我，并指正。</p><ul><li>昵称：David小硕</li><li>职业：移动端技术研发经理</li><li>主攻技术方向：Android; iOS; C++</li><li>公司：北京物灵科技有限公司</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中 基础类型转换成 char *</title>
      <link href="/c++/cplus_type_convert/"/>
      <url>/c++/cplus_type_convert/</url>
      
        <content type="html"><![CDATA[<h1 id="c-中-基础类型转换成-char">C++ 中 基础类型转换成 char*</h1><p>有时候我们在项目中难免会用到，将基础数据类型转换成char*，这样会方面一些业务上的开展。前一阵子做基于mips 平台下 阿里云Log Service时候就用到了，由于考虑要封装sdk的轻量性，所以没有考虑依赖其他的系统库。</p><h3 id="以下demo-代码依赖如下系统库">以下demo 代码依赖如下系统库，</h3><pre><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string&gt;</code></pre><h3 id="基础数据类型的相互转换其实有多种方式-以下多是通过-printf-方式来完成的">基础数据类型的相互转换其实有多种方式。以下多是通过 <code>printf</code> 方式来完成的。</h3><h3 id="int-转-char">int 转 char *</h3><pre><code class="language-c++">char* int_to_char_ptr(int src) {    char result[30] = &quot;&quot;;    sprintf(result, &quot;%d&quot;, src);    char* ret_value = result;    return ret_value;}</code></pre><h3 id="double-转-char">double 转 char*</h3><pre><code class="language-c++">char* double_to_char_ptr(double src) {    char result[30] = &quot;&quot;;    // 如果需要保留小数x位数, eg: %.xlf    sprintf(result, &quot;%lf&quot;, src);    char* ret_value = result;    return ret_value;}</code></pre><h3 id="float-转-char">float 转 char*</h3><pre><code class="language-c++">char* float_to_char_ptr(float src) {    char result[30] = &quot;&quot;;    // 如果需要保留小数x位数, eg: %.xf    sprintf(result, &quot;%f&quot;, src);    char* ret_value = result;    return ret_value;}</code></pre><h3 id="size-t-转-char">size_t 转 char*</h3><pre><code class="language-c++">char* size_t_to_char_ptr(size_t value) {    char result[30] = &quot;&quot;;    sprintf(result, &quot;%zu&quot;, value);    char * ret_value = result;    return ret_value;}</code></pre><h3 id="string-转-char">string 转 char*</h3><pre><code class="language-c++">char* str_to_char_array(std::string value) {    return const_cast&lt;char*&gt;(value.c_str());}</code></pre><h3 id="char-转-string">char* 转 string</h3><pre><code class="language-c++">std::string char_ptr_to_str(const char* value) {    std::string res;    res = value;    return res;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS Terminal 美化 【程序猿推荐】</title>
      <link href="/others/macos_terminal_themes/"/>
      <url>/others/macos_terminal_themes/</url>
      
        <content type="html"><![CDATA[<h1 id="macos-terminal-美化-程序猿推荐">MacOS Terminal 美化 【程序猿推荐】</h1><p><img src="https://travis-ci.org/joemccann/dillinger.svg?branch=master" alt></p><blockquote><p>工欲善其事，必先利其器</p></blockquote><p>我们在MacOS 下开发的时候不可避免一定为会用的terminal，不管你是server端选手，客户端选手，又或者是…哎呀，等等吧，总之terminal是我们在开发中使用评率比较高的基础开发工具了。但是原生的terminal，是一个及其简陋的家伙。那么怎么能让我们的terminal能够看起来既舒服又能超好用呢。动起手来…</p><h2 id="先晒一张我的terminal截图：">先晒一张我的terminal截图：</h2><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/blog_source/master/resources/images/terminal_screenshot.png" alt></p><h2 id="改造terminal步骤">改造Terminal步骤</h2><ul><li><p><a href="https://ohmyz.sh" target="_blank" rel="noopener">安装oh-my-zsh</a></p></li><li><p>设置 oh-my-zsh <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">主题</a></p></li><li><p>安装 oh-my-zsh 日常所需的插件，以提高工作效率</p></li><li><p>修改 Terminal 的Profile，让我们的 Terminal 与 zsh 的主题更加匹配</p></li></ul><h2 id="准备工作-可能会需要">准备工作(可能会需要)</h2><p>首先我们先安装MacOS 中比较好用的软件包管理器 <a href="https://brew.sh" target="_blank" rel="noopener">Homebrew</a></p><pre><code class="language-bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><h2 id="安装-oh-my-zsh">安装 oh-my-zsh</h2><pre><code class="language-bash">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><h2 id="配置-oh-my-zsh-主题">配置 oh-my-zsh 主题</h2><p>首先我们链接到 oh-my-zsh 主题的页面 --&gt; <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a><br>选择我们喜欢的主题，然后记住主题名字，这里我的主题名字是：<strong><u>pygmalion</u></strong></p><p>然后我们打开Terminal窗口输入以下命令对 .zshrc 文件进行编辑</p><pre><code class="language-bash">vim ~/.zshrc// 将 ZSH_THEME 设置为即将要是用的主题名称ZSH_THEME=&quot;pygmalion&quot;</code></pre><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/blog_source/master/resources/images/zshrc_screenshot.png" alt="如图"></p><p>设置成功后，退出vim。执行以下命令，使刚刚的设置生效：</p><pre><code class="language-bash">source ~/.zshrc</code></pre><p>如果你细心你会发现实际上oh-my-zsh在安装的时候已经内置了很多的主题。</p><pre><code class="language-bash">cd ~/.oh-my-zsh/themes // 主题目录cd ~/.oh-my-zsh/plugins // 插件所在目录</code></pre><h2 id="安装oh-my-zsh插件">安装oh-my-zsh插件</h2><p>oh-my-zsh 的插件有很多，它本身内置的插件也有很多，但是我们在用的时候可以根据需要设置需要的即可。<strong><em>因为插件安装过多，一定程度上会使zsh的命令执行效率变低</em></strong></p><h2 id="zsh-syntax-highlighting">zsh-syntax-highlighting</h2><p>zsh 语法高亮插件，<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">官方地址</a></p><pre><code class="language-bash">vim ~/.zshrc//添加如下脚本plugins=(    git    zsh-syntax-highlighting)</code></pre><p>安装效果如下：</p><p><img src="https://raw.githubusercontent.com/zsh-users/zsh-syntax-highlighting/master/images/after2.png" alt></p><h2 id="修改-terminal-的profile-导入我们想要的主题-我选择的是fideloper">修改 Terminal 的Profile，导入我们想要的主题 【我选择的是<strong><em>Fideloper</em></strong>】</h2><p><a href="https://github.com/lysyi3m/macos-terminal-themes" target="_blank" rel="noopener">macos-terminal-themes</a> 提供了丰富的主题供我们选择，我们可以在当中找一款与我们所选zsh主题相符合的主题。</p><ul><li>将 macos-terminal-themes 下载到本地</li><li>进入到 schemes 目录下</li><li>双击 *.terminal 的文件，将会打开一个所选主题的新的Terminal窗口</li><li>选择Terminal 工具栏中的 Shell -&gt; Use Setting as Default, 即将主题修改为所选主题。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android studio cmake 编译常规设置</title>
      <link href="/android/cmake_list/"/>
      <url>/android/cmake_list/</url>
      
        <content type="html"><![CDATA[<h1 id="android-studio-cmake-编译常规设置">android studio cmake 编译常规设置</h1><h3 id="add-executable-指令">add_executable 指令</h3><p>语法：<code>add_executable(executable_file_name [source])</code>将一组源文件 source 生成一个可执行文件。 source  可以是多个源文件，也可以是对应定义的变量  如：<code>add_executable(hello main.c)</code></p><h3 id="cmake-minimun-required-version-3-4-1">cmake_minimun_required(VERSION 3.4.1)</h3><p>用来指定 CMake 最低版本为3.4.1，如果没指定，执行 cmake 命令时可能会出错</p><h3 id="add-subdirectory-指令">add_subdirectory 指令</h3><p>语法：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></p><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。<code>EXCLUDE_FROM_ALL</code>参数含义是将这个目录从编译过程中排除。</p><p>另外，也可以通过 SET 指令重新定义<code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code>  变量来指定最终的目标二进制的位置 (指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件)</p><pre><code>set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</code></pre><h3 id="add-library-指令">add_library 指令</h3><p>语法：<code>add_library(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])</code></p><p>将一组源文件 source 编译出一个库文件，并保存为 <a href="http://libname.so" target="_blank" rel="noopener">libname.so</a> (lib 前缀是生成文件时 CMake自动添加上去的)。其中有三种库文件类型，<strong>不写的话，默认为 STATIC</strong>:</p><ul><li>SHARED: 表示动态库，可以在(Java)代码中使用<code>System.loadLibrary(name)</code>动态调用；</li><li>STATIC: 表示静态库，集成到代码中会在编译时调用；</li><li>MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待；</li><li>EXCLUDE_FROM_ALL:  表示这个库不被默认构建，除非其他组件依赖或手工构建</li></ul><pre><code>#将compress.c 编译成 libcompress.so 的共享库add_library(compress SHARED compress.c)</code></pre><ul><li>add_library 命令也可以用来导入第三方的库:<code>add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED)</code> 如，导入 <a href="http://libjpeg.so" target="_blank" rel="noopener">libjpeg.so</a></li></ul><pre><code class="language-cmake">add_library(libjpeg SHARED IMPORTED)</code></pre><p>导入库后，当需要使用 target_link_libraries 链接库时，可以直接使用该库</p><h3 id="find-library-指令">find_library 指令</h3><p>语法：<code>find_library(name1 path1 path2 …)</code>VAR 变量表示找到的库全路径，包含库文件名 。例如：</p><pre><code>find_library(libX  X11 /usr/lib)find_library(log-lib log)#路径为空，应该是查找系统环境变量路径</code></pre><h3 id="set-target-properties-指令">set_target_properties 指令</h3><p>语法:<code>set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)</code>这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），对于动态库，还可以用来指定动态库版本和 API 版本。如: <code>set_target_properties(hello_static PROPERTIES OUTPUT_NAME “hello”)</code> 设置同名的 hello 动态库和静态库：</p><pre><code>set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)set_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)</code></pre><p>指定要导入的库文件的路径</p><pre><code>add_library(jpeg SHARED IMPORTED)#注意要先 add_library，再 set_target_propertiesset_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so)</code></pre><p>设置动态库 hello 版本和 API 版本：<code>set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code>和它对应的指令：<code>get\_target_property(VAR target property)</code>。如上面的例子，获取输出的库的名字</p><pre><code>get_target_property(OUTPUT_VALUE hello_static OUTPUT_NAME)message(STATUS &quot;this is the hello_static OUTPUT_NAME:&quot;${OUTPUT_VALUE})</code></pre><h3 id="include-directories-指令">include_directories 指令</h3><p>语法：<code>include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)</code></p><p>这个指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。</p><h3 id="target-link-libraries-指令">target_link_libraries 指令</h3><p>语法：<code>target_link_libraries(target library library2…)</code></p><p>这个指令可以用来为 target 添加需要的链接的共享库，同样也可以用于为自己编写的共享库添加共享库链接。如：</p><pre><code>#指定 compress 工程需要用到 libjpeg 库和 log 库target_link_libraries(compress libjpeg ${log-lib})</code></pre><p>同样，link_directories(directory1 directory2 …) 可以添加非标准的共享库搜索路径。还有其他 file、list、install 、find_ 指令和控制指令等就不介绍了，详细可以查看手册。</p><h3 id="cmake-的常用变量">CMake 的常用变量</h3><ul><li>变量引用方式</li></ul><p>使用 ${} 进行变量的引用。不过在 IF 等语句中，可以直接使用变量名而不用通过 ${} 取值</p><ul><li><p>自定义变量的方式</p><p>主要有隐式定义和显式定义两种。隐式定义，如 PROJECT 指令会隐式定义<code>_BINARY_DIR</code> 和<code>_SOURCE_DIR</code>而对于显式定义就是通过 SET 指令来定义。如：set(HELLO_SRC main.c)</p></li><li><p>CMake 常用变量</p><ul><li><code>CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, _BINARY_DIR</code>这三个变量指代的内容都是一样的，如果是 in-source 编译，指的是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。</li><li><code>CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, _SOURCE_DIR</code>这三个变量指代的内容也是一样的，不论哪种编译方式，都是工程顶层目录。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>当前处理的 CMakeLists.txt 所在的路径</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>如果是 in-source 编译，它跟            CMAKE_CURRENT_SOURCE_DIR 一致，如果是 <code>out-of-source</code> 编译，指的是 target 编译目录。使用 ADD_SUBDIRECTORY(src bin)可以修改这个变量的值；而使用 <code>SET(EXECUTABLE_OUTPUT_PATH &amp;lt; 新路径&amp;gt;)</code> 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。</li><li><code>CMAKE_CURRENT_LIST_FILE</code> 输出调用这个变量的 CMakeLists.txt 的完整路径</li><li><code>CMAKE_CURRENT_LIST_LINE</code> 输出这个变量所在的行</li><li><code>CMAKE_MODULE_PATH</code> 这个变量用来定义自己的 CMake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。比如：<code>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</code> 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。</li><li><code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code>分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。</li><li><code>PROJECT_NAME</code>返回通过 PROJECT 指令定义的项目名称。</li></ul></li></ul><h3 id="android-cmake-的使用">Android CMake 的使用</h3><h4 id="cmakelist-txt-的编写">CMakeList.txt 的编写</h4><p>再回归到 Android NDK 开发中 CMake 的使用，先看一个系统生成的 NDK 项目的 CMakeLists.txt 的配置：(去掉原有的注释)</p><pre><code># 设置编译 native library 需要最小的 cmake 版本cmake_minimum_required(VERSION 3.4.1)# 将指定的源文件编译为名为 libnative-lib.so 的动态库add_library(native-lib SHARED src/main/cpp/native-lib.cpp)# 查找本地 log 库find_library(log-lib log)# 将预构建的库添加到自己的原生库target_link_libraries(native-lib ${log-lib})</code></pre><p>复杂一点的 CMakeLists，这是一个本地使用 <a href="http://libjpeg.so" target="_blank" rel="noopener">libjpeg.so</a> 来做图片压缩的项目</p><pre><code>cmake_minimum_required(VERSION 3.4.1)#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI})#指定要引用的libjpeg.so的头文件目录set(LIBJPEG_INCLUDE_DIR src/main/cpp/include)include_directories(${LIBJPEG_INCLUDE_DIR})#导入libjpeg动态库 SHARED；静态库为STATICadd_library(jpeg SHARED IMPORTED)#对应so目录，注意要先 add_library，再 set_target_properties）set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so)add_library(compress SHARED src/main/cpp/compress.c)find_library(graphics jnigraphics)find_library(log-lib log)#添加链接上面个所 find 和 add 的 librarytarget_link_libraries(compress jpeg ${log-lib} ${graphics})</code></pre><h4 id="配置-gradle">配置 Gradle</h4><p>简单的配置如下，至于 cppFlags 或 cFlags 的参数有点复杂，一般设置为空或不设置也是可以的，这里就不过多介绍了</p><pre><code>android {compileSdkVersion 25buildToolsVersion &quot;25.0.3&quot;defaultConfig {    minSdkVersion 15    targetSdkVersion 25    versionCode 1    versionName &quot;1.0&quot;    externalNativeBuild {        cmake {            // Passes optional arguments to CMake.            arguments             &quot;-DANDROID_ARM_NEON=TRUE&quot;,            &quot;-DANDROID_TOOLCHAIN=clang&quot;            // Sets optional flags for the C compiler.            cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;,&quot;-D_EXAMPLE_C_FLAG2&quot;            // Sets a flag to enable format macro constants for the C++ compiler.            cppFlags &quot;-D__STDC_FORMAT_MACROS&quot;            //生成.so库的目标平台            abiFilters 'x86','x86_64','armeabi','armeabi-v7a','arm64-v8a'        }    }}//配置 CMakeLists.txt 路径externalNativeBuild {     cmake {        path &quot;CMakeLists.txt&quot;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 多github（gitlab）账号管理</title>
      <link href="/git/git_multi_account_manager/"/>
      <url>/git/git_multi_account_manager/</url>
      
        <content type="html"><![CDATA[<h1 id="git-多github-gitlab-账号管理">Git 多github（gitlab）账号管理</h1><p>场景：很多时候我们有公司的github的账号同时自己私下还可能会有多个git平台的账号（如：github，gitlab）。这时候在管理git账号，指定哪个项目用哪个账号，放在哪个账户的仓库下，就显得尤为重要了。下面简单说下如何配置git config 文件去管理这些git平台账号。</p><h4 id="1-生成ssh-key">1. 生成ssh-key</h4><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@company.com” -f ~/.ssh/id-rsa</code></pre><p><strong>explain</strong>：这样在~/.ssh/目录下就会生成id-rsa和id-rsa.pub的公钥和私钥。其中id-rsa 我们可以根据我们自己的需求来定义名称，例如我的名称personal-github-id-rsa(私人），company-github-id-rsa（公司github），company-gitlab-id-rsa（公司gitlab）。生成ssh-key 后我们可以copy 公钥到各git平台</p><pre><code>$ pbcopy &lt; ~/.ssh/id-rsa</code></pre><p>通过上面的命令将公钥copy到剪贴板，然后到git平台的ssh-key页面直接粘贴即可。</p><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/mybook/master/assets/remote_repository_ssh_url.png" alt></p><h4 id="2-添加私钥">2. 添加私钥</h4><pre><code>$ ssh-add ~/.ssh/id-rsa</code></pre><p>将私钥添加到我们本地ssh中</p><pre><code># 可以通过 ssh-add -l 来确私钥列表$ ssh-add -l# 可以通过 ssh-add -D 来清空私钥列表$ ssh-add -D</code></pre><h4 id="3-创建多账号管理文件">3. 创建多账号管理文件</h4><pre><code>touch ~/.ssh/configvim config</code></pre><pre><code># gitlab    Host gitlab.com     HostName gitlab.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/company-gitlab-id-rsa# githubHost github-company     HostName github.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/company-github-id-rsa#personal-githubHost github-personal     HostName github.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/personal-github-rsa</code></pre><p><strong>explain</strong>: Host 这里可以理解为我们为实际的host（如：<a href="http://github.com" target="_blank" rel="noopener">github.com</a>）起的别名，HostName才是实际的host address值，这样我们在本地仓库指定远程仓库的时候就可以区分出同一个平台下的不同账号体系了，可以通过下面的remote repository 地址可以看出。</p><h4 id="4-为本地仓库指定远程仓库地址">4. 为本地仓库指定远程仓库地址</h4><h5 id="4-1-远程仓库地址-从github中直接复制显示：">4.1 远程仓库地址，从github中直接复制显示：</h5><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/mybook/master/assets/remote_repository_ssh_url.png" alt></p><h5 id="4-2-实际为本地仓库指定远程仓库地址需要这样：">4.2 实际为本地仓库指定远程仓库地址需要这样：</h5><pre><code>添加地址：git remote add origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git重定向地址：git remote set-url origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git</code></pre><p><strong>explain</strong>: 其中git@后面的字段为我们在config配置文件中的Host的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/others/hello_world/"/>
      <url>/others/hello_world/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-page-简单发布流程">Hexo Page 简单发布流程</h1><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

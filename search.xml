<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 多github（gitlab）账号管理</title>
      <link href="/2019/04/24/android/cmake-list/"/>
      <url>/2019/04/24/android/cmake-list/</url>
      
        <content type="html"><![CDATA[<h2 id="android-studio-cmake-编译常规设置"><a href="#android-studio-cmake-编译常规设置" class="headerlink" title="android studio cmake 编译常规设置"></a><strong>android studio cmake 编译常规设置</strong></h2><h4 id="1-add-executable-指令"><a href="#1-add-executable-指令" class="headerlink" title="1. add_executable 指令"></a>1. add_executable 指令</h4><p>语法：add_executable(executable_file_name [source])<br>将一组源文件 source 生成一个可执行文件。 source 可以是多个源文件，也可以是对应定义的变量<br>如：add_executable(hello main.c)</p><h4 id="2-cmake-minimun-required-VERSION-3-4-1"><a href="#2-cmake-minimun-required-VERSION-3-4-1" class="headerlink" title="2. cmake_minimun_required(VERSION 3.4.1)"></a>2. cmake_minimun_required(VERSION 3.4.1)</h4><p>用来指定 CMake 最低版本为3.4.1，如果没指定，执行 cmake 命令时可能会出错</p><h4 id="3-add-subdirectory-指令"><a href="#3-add-subdirectory-指令" class="headerlink" title="3. add_subdirectory 指令"></a>3. add_subdirectory 指令</h4><p>语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数含义是将这个目录从编译过程中排除。</p><p>另外，也可以通过 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置(指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件)</p><p>set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</p><p>set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><h4 id="4-add-library-指令"><a href="#4-add-library-指令" class="headerlink" title="4. add_library 指令"></a>4. add_library 指令</h4><p>语法：add_library(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])</p><p>将一组源文件 source 编译出一个库文件，并保存为 libname.so (lib 前缀是生成文件时 CMake自动添加上去的)。其中有三种库文件类型，<strong>不写的话，默认为 STATIC</strong>:</p><ul><li>SHARED: 表示动态库，可以在(Java)代码中使用<br><code>System.loadLibrary(name)</code><br>动态调用；</li><li>STATIC: 表示静态库，集成到代码中会在编译时调用；</li><li>MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待；</li><li>EXCLUDE_FROM_ALL: 表示这个库不被默认构建，除非其他组件依赖或手工构建<pre><code>#将compress.c 编译成 libcompress.so 的共享库add_library(compress SHARED compress.c)</code></pre></li></ul><p>add_library 命令也可以用来导入第三方的库:</p><p><code>add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED)</code></p><p>如，导入 libjpeg.so</p><pre><code>add_library(libjpeg SHARED IMPORTED)</code></pre><p>导入库后，当需要使用 target_link_libraries 链接库时，可以直接使用该库</p><h4 id="5-find-library-指令"><a href="#5-find-library-指令" class="headerlink" title="5. find_library 指令"></a>5. find_library 指令</h4><p>语法：find_library(</p><p>name1 path1 path2 …)</p><p>VAR 变量表示找到的库全路径，包含库文件名 。例如：</p><pre><code>find_library(libX  X11 /usr/lib)find_library(log-lib log)#路径为空，应该是查找系统环境变量路径</code></pre><h4 id="6-set-target-properties-指令"><a href="#6-set-target-properties-指令" class="headerlink" title="6. set_target_properties 指令"></a>6. set_target_properties 指令</h4><p>语法: set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)</p><p>这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），对于动态库，还可以用来指定动态库版本和 API 版本。</p><p>如，set_target_properties(hello_static PROPERTIES OUTPUT_NAME “hello”)</p><p>设置同名的 hello 动态库和静态库：</p><pre><code>set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)set_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)</code></pre><p>指定要导入的库文件的路径</p><pre><code>add_library(jpeg SHARED IMPORTED)#注意要先 add_library，再 set_target_propertiesset_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so)</code></pre><p>设置动态库 hello 版本和 API 版本：</p><p><code>set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>和它对应的指令：</p><p>get_target_property(VAR target property)</p><p>如上面的例子，获取输出的库的名字</p><pre><code>get_target_property(OUTPUT_VALUE hello_static OUTPUT_NAME)message(STATUS &quot;this is the hello_static OUTPUT_NAME:&quot;${OUTPUT_VALUE})</code></pre><h4 id="7-include-directories-指令"><a href="#7-include-directories-指令" class="headerlink" title="7.include_directories 指令"></a>7.include_directories 指令</h4><p>语法：include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)</p><p>这个指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。</p><h4 id="8-target-link-libraries-指令"><a href="#8-target-link-libraries-指令" class="headerlink" title="8. target_link_libraries 指令"></a>8. target_link_libraries 指令</h4><p>语法：target_link_libraries(target library</p><p>library2…)</p><p>这个指令可以用来为 target 添加需要的链接的共享库，同样也可以用于为自己编写的共享库添加共享库链接。</p><p>如：</p><pre><code>#指定 compress 工程需要用到 libjpeg 库和 log 库target_link_libraries(compress libjpeg ${log-lib})</code></pre><p>同样，link_directories(directory1 directory2 …) 可以添加非标准的共享库搜索路径。</p><p>还有其他 file、list、install 、find_ 指令和控制指令等就不介绍了，详细可以查看手册。</p><h3 id="9-CMake-的常用变量"><a href="#9-CMake-的常用变量" class="headerlink" title="9. CMake 的常用变量"></a>9. CMake 的常用变量</h3><h4 id="9-1-变量引用方式"><a href="#9-1-变量引用方式" class="headerlink" title="9.1 变量引用方式"></a>9.1 变量引用方式</h4><p>使用 ${} 进行变量的引用。不过在 IF 等语句中，可以直接使用变量名而不用通过 ${} 取值</p><h4 id="9-2-自定义变量的方式"><a href="#9-2-自定义变量的方式" class="headerlink" title="9.2 自定义变量的方式"></a>9.2 自定义变量的方式</h4><p>主要有隐式定义和显式定义两种。隐式定义，如 PROJECT 指令会隐式定义</p><p>_BINARY_DIR 和</p><p>_SOURCE_DIR</p><p>而对于显式定义就是通过 SET 指令来定义。如：set(HELLO_SRC main.c)</p><h4 id="9-3-CMake-常用变量"><a href="#9-3-CMake-常用变量" class="headerlink" title="9.3 CMake 常用变量"></a>9.3 CMake 常用变量</h4><ul><li><p>1）CMAKE_BINARY_DIR, PROJECT_BINARY_DIR,<br>_BINARY_DIR</p><p>这三个变量指代的内容都是一样的，如果是 in-source 编译，指的是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。</p></li><li><p>2）CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR,<br>_SOURCE_DIR</p><p>这三个变量指代的内容也是一样的，不论哪种编译方式，都是工程顶层目录。</p></li><li><p>3）CMAKE_CURRENT_SOURCE_DIR</p><p>当前处理的 CMakeLists.txt 所在的路径</p></li><li><p>4）CMAKE_CURRENT_BINARY_DIR</p><p>如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致，如果是 out-of-source 编译，指的是 target 编译目录。</p><p>使用 ADD_SUBDIRECTORY(src bin)可以修改这个变量的值；</p><p>而使用 SET(EXECUTABLE_OUTPUT_PATH &lt; 新路径&gt;) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。</p></li><li><p>5）CMAKE_CURRENT_LIST_FILE</p><p>输出调用这个变量的 CMakeLists.txt 的完整路径</p></li><li><p>6）CMAKE_CURRENT_LIST_LINE</p><p>输出这个变量所在的行</p></li><li><p>7）CMAKE_MODULE_PATH</p><p>这个变量用来定义自己的 CMake 模块所在的路径。如果你的工程比较复杂，有可能会自己</p><p>编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理</p><p>CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设</p><p>置一下。</p><p>比如 SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</p><p>这时候你就可以通过 INCLUDE 指令来调用自己的模块了。</p></li><li><p>８）EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH</p><p>分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。</p></li><li><p>9）PROJECT_NAME</p><p>返回通过 PROJECT 指令定义的项目名称。</p></li></ul><h3 id="Android-CMake-的使用"><a href="#Android-CMake-的使用" class="headerlink" title="Android CMake 的使用"></a>Android CMake 的使用</h3><h4 id="8-1-CMakeList-txt-的编写"><a href="#8-1-CMakeList-txt-的编写" class="headerlink" title="8.1 CMakeList.txt 的编写"></a>8.1 CMakeList.txt 的编写</h4><p>再回归到 Android NDK 开发中 CMake 的使用，先看一个系统生成的 NDK 项目的 CMakeLists.txt 的配置：( 去掉原有的注释)</p><pre><code>#设置编译 native library 需要最小的 cmake 版本cmake_minimum_required(VERSION 3.4.1)#将指定的源文件编译为名为 libnative-lib.so 的动态库add_library(native-lib SHARED src/main/cpp/native-lib.cpp)#查找本地 log 库find_library(log-lib log)#将预构建的库添加到自己的原生库target_link_libraries(native-lib ${log-lib})</code></pre><p>复杂一点的 CMakeLists，这是一个本地使用 libjpeg.so 来做图片压缩的项目</p><pre><code>cmake_minimum_required(VERSION 3.4.1)#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI})#指定要引用的libjpeg.so的头文件目录set(LIBJPEG_INCLUDE_DIR src/main/cpp/include)include_directories(${LIBJPEG_INCLUDE_DIR})#导入libjpeg动态库 SHARED；静态库为STATICadd_library(jpeg SHARED IMPORTED)#对应so目录，注意要先 add_library，再 set_target_properties）set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so)add_library(compress SHARED src/main/cpp/compress.c)find_library(graphics jnigraphics)find_library(log-lib log)#添加链接上面个所 find 和 add 的 librarytarget_link_libraries(compress jpeg ${log-lib} ${graphics})</code></pre><h4 id="配置-Gradle"><a href="#配置-Gradle" class="headerlink" title="配置 Gradle"></a>配置 Gradle</h4><p>简单的配置如下，至于 cppFlags 或 cFlags 的参数有点复杂，一般设置为空或不设置也是可以的，这里就不过多介绍了</p><pre><code>android {compileSdkVersion 25buildToolsVersion &quot;25.0.3&quot;defaultConfig {        minSdkVersion 15        targetSdkVersion 25        versionCode 1        versionName &quot;1.0&quot;        externalNativeBuild {           cmake {                // Passes optional arguments to CMake.                arguments                 &quot;-DANDROID_ARM_NEON=TRUE&quot;,                &quot;-DANDROID_TOOLCHAIN=clang&quot;                // Sets optional flags for the C compiler.                cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;,&quot;-D_EXAMPLE_C_FLAG2&quot;                // Sets a flag to enable format macro constants for the C++ compiler.                cppFlags &quot;-D__STDC_FORMAT_MACROS&quot;                //生成.so库的目标平台                abiFilters &#39;x86&#39;,&#39;x86_64&#39;,&#39;armeabi&#39;,&#39;armeabi-v7a&#39;,&#39;arm64-v8a&#39;                }        }}//配置 CMakeLists.txt 路径    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;            }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 多github（gitlab）账号管理</title>
      <link href="/2019/04/23/git/git-multi-account-manager/"/>
      <url>/2019/04/23/git/git-multi-account-manager/</url>
      
        <content type="html"><![CDATA[<p>场景：很多时候我们有公司的github的账号同时自己私下还可能会有多个git平台的账号（如：github，gitlab）。这时候在管理git账号，指定哪个项目用哪个账号，放在哪个账户的仓库下，就显得尤为重要了。下面简单说下如何配置git config 文件去管理这些git平台账号。</p><h4 id="1-生成ssh-key"><a href="#1-生成ssh-key" class="headerlink" title="1. 生成ssh-key"></a>1. 生成ssh-key</h4><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@company.com” -f ~/.ssh/id-rsa</code></pre><p><strong>explain</strong>：这样在~/.ssh/目录下就会生成id-rsa和id-rsa.pub的公钥和私钥。其中id-rsa 我们可以根据我们自己的需求来定义名称，例如我的名称personal-github-id-rsa(私人），company-github-id-rsa（公司github），company-gitlab-id-rsa（公司gitlab）。生成ssh-key 后我们可以copy 公钥到各git平台</p><pre><code>$ pbcopy &lt; ~/.ssh/id-rsa</code></pre><p>通过上面的命令将公钥copy到剪贴板，然后到git平台的ssh-key页面直接粘贴即可。</p><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/mybook/master/assets/remote_repository_ssh_url.png" alt></p><h4 id="2-添加私钥"><a href="#2-添加私钥" class="headerlink" title="2. 添加私钥"></a>2. 添加私钥</h4><pre><code>$ ssh-add ~/.ssh/id-rsa</code></pre><p>将私钥添加到我们本地ssh中</p><pre><code># 可以通过 ssh-add -l 来确私钥列表$ ssh-add -l# 可以通过 ssh-add -D 来清空私钥列表$ ssh-add -D</code></pre><h4 id="3-创建多账号管理文件"><a href="#3-创建多账号管理文件" class="headerlink" title="3. 创建多账号管理文件"></a>3. 创建多账号管理文件</h4><pre><code>touch ~/.ssh/configvim config</code></pre><pre><code># gitlab    Host gitlab.com     HostName gitlab.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/company-gitlab-id-rsa# githubHost github-company     HostName github.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/company-github-id-rsa#personal-githubHost github-personal     HostName github.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/personal-github-rsa</code></pre><p><strong>explain</strong>: Host 这里可以理解为我们为实际的host（如：github.com）起的别名，HostName才是实际的host address值，这样我们在本地仓库指定远程仓库的时候就可以区分出同一个平台下的不同账号体系了，可以通过下面的remote repository 地址可以看出。</p><h4 id="4-为本地仓库指定远程仓库地址"><a href="#4-为本地仓库指定远程仓库地址" class="headerlink" title="4. 为本地仓库指定远程仓库地址"></a>4. 为本地仓库指定远程仓库地址</h4><h5 id="4-1-远程仓库地址，从github中直接复制显示："><a href="#4-1-远程仓库地址，从github中直接复制显示：" class="headerlink" title="4.1 远程仓库地址，从github中直接复制显示："></a>4.1 远程仓库地址，从github中直接复制显示：</h5><p><img src="https://raw.githubusercontent.com/Davidxiaoshuo/mybook/master/assets/remote_repository_ssh_url.png" alt></p><h5 id="4-2-实际为本地仓库指定远程仓库地址需要这样："><a href="#4-2-实际为本地仓库指定远程仓库地址需要这样：" class="headerlink" title="4.2 实际为本地仓库指定远程仓库地址需要这样："></a>4.2 实际为本地仓库指定远程仓库地址需要这样：</h5><pre><code>添加地址：git remote add origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git重定向地址：git remote set-url origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git</code></pre><p><strong>explain</strong>: 其中git@后面的字段为我们在config配置文件中的Host的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>David-Blog</title>
      <link href="/2019/04/19/david-blog/"/>
      <url>/2019/04/19/david-blog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/19/hello-world/"/>
      <url>/2019/04/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

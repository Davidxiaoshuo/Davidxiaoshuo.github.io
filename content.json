{"meta":{"title":"David硕","subtitle":"write readable code","description":"在这个薄情的世界，深情地活着","author":"David硕","url":"http://davidxiaoshuo.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-14T08:13:41.882Z","updated":"2019-08-14T08:13:41.882Z","comments":false,"path":"/404.html","permalink":"http://davidxiaoshuo.github.io//404.html","excerpt":"","text":""},{"title":"category","date":"2021-06-19T08:46:45.000Z","updated":"2021-06-19T09:01:01.815Z","comments":true,"path":"category/index.html","permalink":"http://davidxiaoshuo.github.io/category/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2021-07-02T08:26:18.610Z","updated":"2021-07-02T08:26:18.610Z","comments":false,"path":"about/index.html","permalink":"http://davidxiaoshuo.github.io/about/index.html","excerpt":"","text":"自我评价​ 本人具有丰富的 iOS / Android 双端开发经验，具有一定的团队管理经验。乐观积极，强烈的责任心与执行能力，超强的学习能力，良好的业务推动能力，优良的跨团队、跨部门沟通协作能力。具有优秀的编码能力，问题分析 &amp; 定位能力，优良的架构设计能力，良好的编码风格。以下几点是自我评价的具体实例：主导产品大版本升级工作，Luka App 2.0 主导 App 架构设计，协助后端同学设计 API，并最终落地发布。引入新的技术方案，全面推动 GraphQL API 落地设计优化重构核心 SDK ，并从内部孵化提供给第三方使用。带领团队高效快速的进行版本迭代。Luka 2.0 App 已经由 2.0.0 版本快速迭代到 2.22.0 版本工作经历2016.10 ~ 至今 北京物灵科技有限公司移动端研发架构「负责人」工作描述：主导 Luka App 2.0 的研发负责产品技术选型 &amp; 核心功能组件研发 &amp; 新技术方案引入。负责 App + 设备端团队的质量管理：CodeReview + CI / CD。负责 App + 设备端团队的版本迭代技术实现把控。负责协调各方资源并规划和分配，配合项目经理高效高质推进项目。负责 PC 端产测客户端的研发。2015.5 ~ 2016.9 百度移动端高级研发工程师工作描述：负责 IDL - HCI 组 DuBike 项目 Android App 端研发工作负责 DuBike App 与硬件组进行对接工作负责 IDL - HCI 组 脸优 项目 iOS App 端的研发工作负责 人脸贴纸 SDK 的设计 &amp; 研发工作 &amp; 对完开放对接负责 人脸闸机，公司内部 iOS App 的研发工作2014.5 ~ 2015.5 软通动力 - 百度 IDLAndroid 高级研发工程师工作描述：负责 IDL - HCI 组 DuBike 项目 Android App 端研发工作负责 DuBike App 与硬件通信协议的设计 &amp; 研发负责协助 PM 定义 DuBike 功能需求2012.1 ~ 2014.5 北京博力恒昌科技有限公司Android 研发工程师工作描述：负责智能家居中控端「Android OS」研发落地负责智能家居 Android - App 的研发落地参与 Zigbee 消息报文的制定 &amp; 解析 &amp; 封装工作负责公司售后技术支持工作项目经历Luka 阅读养成什么是 Luka 阅读养成​ Luka借助前沿的人工智能（AI）技术与生动灵性的角色设计，为2岁以上的宝宝家庭创造有未来感的绘本阅读体验。培养孩子绘本阅读兴趣、养成绘本阅读习惯、推荐绘本， 简单快捷一站式帮助父母满足孩子们对看绘本听故事的渴望，为阅读敏感期的孩子培养受用一生的宝贵阅读习惯。通过，绘本在线 &amp; 离线阅读、听听音频在线 / 离线播放、语音交互，App 实时操控设备等功能，加持 LingUI 关系式交互，使得 Luka 成为一个灵气十足的，陪伴宝宝一起成长的阅读小伙伴。Luka 绘本阅读机器人的使命是什么​ 让孩子从屏幕回归书本。Luka 项目团队规模​ 该项目隶属于公司 KID 业务线。我们在 App 端「iOS &amp; Android」分别投入 2 人力进行支持；设备端「Robot端」投入 3人力进行支持。完整的后台分布式服务 + CMS 后台管理系统 + 产测服务 + 产测客户端 + CV 算法。Luka 绘本阅读机器人的几大功能离线/在线绘本阅读能力，多模式CV识别能力「手指指读，跟读，精读，评分」。宝宝书架、拍录绘本、绘本录音个性化绘本能力。四大分类听听音频、宝宝歌单、专辑绑定、专属云盘、播放足迹，超多超精音频资源。从唤醒，识别，理解，语音合成「Wakeup - ASR - NLP - TTS」的全链条语音能力。视频课程、定时熏听，定制化的课程辅导能力。Luka 阅读养成 App-iOS 2.0​ 支持 iOS 9.0 及以上系统。架构： MVVM，整体组合套件：MVVM + GraphQL API「Apollo」+ IM 通讯 + Realm + ReactiveKit + Router方案选型：开发语言：Swift，基于 SwiftLint 管控代码规范。网络服务框架： 采用 Facebook 的出品的 GraphQL API ，基于Apollo 封装网络框架。IM 通讯服务：基于腾讯云通信 TIM、网易云信 NIM，阿里云 MQTT 封装 MessagePluginBox，可根据业务 &amp; SKU 选择不同服务通道。模块通信：基于自定义 Router 路由机制。数据存储：本地数据基于 Realm 数据库，远程文件资源存储基于 Aliyun-OSS。App 异常监测：前期采用 Fabric，后期采用腾讯 Bugly。App 统计服务：采用神策埋点统计服务。Luka 阅读养成 App-Android 2.0​ 支持 Android 5.0 及以上。​ 前期架构： MVP， 整体组合套件： MVP + GraphQL API「Apollo」+ IM 通讯 + Realm + Router​ 后期架构： MVVM， 整体组合套件：MVVM + GraphQL API「Apollo」+ IM 通讯 + Realm + Router + Jetpack方案选型：开发语言： kotlin, 基于 ktlint 管控代码规范网络服务框架： 采用 Facebook 的出品的 GraphQL API ，基于Apollo 封装网络框架。IM 通讯服务：基于腾讯云通信 TIM、网易云信 NIM，阿里云 MQTT 封装 MessagePluginBox，可根据业务 &amp; SKU 选择不同服务通道。模块通信：基于自定义 Router 路由机制。数据存储：本地数据基于 Realm 数据库，远程文件资源存储基于 Aliyun-OSS。App 异常监测：前期采用 Fabric，后期采用腾讯 Bugly。App 统计服务：采用神策埋点统计服务。主要产出App 整体架构设计，搭建GraphQL API 新技术引进，内部推广，Apollo 网络框架二次封装，使之更切合项目需求需要，并解决 Authorization 不同状态的访问问题。MessagePluginBox 封装，制定消息自定义协议，以及消息交互机制，输出 Messenger Fragment 可提供第三方使用的 Framework 级别。「框架介绍」制定 Router 路由协议，输出自定义 Router 框架others：多语言「i18n」自动化脚本；GraphQL 多端统一请求自动化脚本；iOS-CI/CD 整体环境搭建；Luka RobotSKU目前 Luka 系列 针对孩子不同年龄段，不同家长用户需求，不同的销售渠道，已经研发了多款 SKU ：Android OS：Luka HeroS、Luka Hero、LukaLinux OS「T20」：Luka BabyATOS: Luka Mini、 JiFeiFei、Luka Box其中 Android OS &amp; Linux OS「T20」系列 SKU 由公司内部自研。Android OS 由本人主导研发，Linux 参与研发。ATOS 方案 SKU 采用外部合作方式进行研发, 本人负责主导外部研发协调，对接工作。Robot App 「Android」方案选型：Android 4.4 + 模块化 + 事件驱动架构； 输出 Luka App、Hardware Test App、OTA App开发语言: 业务部分 kotlin，基于 ktlint 管控代码规范；底层能力部分 c++网络服务框架：Retrofit 2.0语音模块：前期采用科大讯飞 + 先声 SDK；后期切换到腾讯叮当图像识别：LingCV 「此部分为公司算法自研部分」UI 模块： Unity 3D 自研动画表情音频播放器： 基于IjkPlayer 封装的 LingPlayer 音频播放器App 异常监测：前期采用 Fabric，后期采用腾讯 Bugly。App 统计服务：采用神策埋点统计服务。主要产出：Robot App 整体架构设计，搭建绘本识别，多模式识别设计，配合 Unity 3D 优化表情平滑过渡表现。疑难问题解决，如语音交互，音频数据采集，加工导致出现杂音，出现丢帧现象等问题。基于IjkPlayer 封装的 LingPlayer 音频播放器，并针对需求，对 ffmpeg 进行裁剪，减小包体积利用 RTC 时钟芯片，修改 Framework 层代码，实现定时开机功能基于阿里云 SLS 日志服务，封装出 Android SDKRobot Hardware Test 「Win-PC 版」​ PC 端产测主要服务于工厂生产。在工厂生产过程中，对设备进行：设备码烧录，初始化设置，资源烧录，硬件元器件检测，老化，装箱，拆箱等操作，辅助工厂进行设备生产流程。主要产出产测基础功能实现串口命令设计基础组件设计 &amp; 实现##Auri 智能灯什么是 Auri​ Planet Auri，借助 Amazon Alexa 内核，同时兼具氛围，照明功能的一款家庭助理智能灯。Auri 智能灯的使命是什么​ 面向家庭场景的HOMEAI产品线，让灵性真正走入未来人们的生活中，为成年人及家庭生活带来品质升级。Auri 项目团队规模​ 该项目隶属于公司 Home 业务线，我们在 App 「iOS」端，投入两人力；在 Robot 端研发上投入两人力；在 Server 后台投入两人力。Auri 智能灯的几大功能智能语音交互 Alexa根据音乐舞动灯光多种氛围灯效闹钟、提醒等基础功能个人职责 「移动端负责人」负责 设备端 &amp; App 项目框架设计负责产品技术选型 &amp; 核心功能组件研发。配合产品经理讨论需求定义指导并带领初级工程师进行版本迭代任务主要产出Alexa Android SDK 开发并集成。配合算法同学产出一套根据音乐节奏舞动灯光的 SDK。搭建 iOS App 的整体架构，网络请求 SDK。输出一篇专利：《一种调整多媒体环境的方法、装置及存储设备》脸优什么是脸优​ 脸优，一款以实时摄像为使用方式的趣味性换脸娱乐app，采用基于人脸特征点定位的人脸检测技术、表情迁移技术、图像融合技术，一个全民都能玩的“黑科技”产品。用户通过脸优app生成的作品，可以分享到多个sns社区。脸优的使命脸优FaceIt，就是要玩出“鬼”！方案选型「iOS」：开发语言采用 Swift + OC 混编， MVC 架构Baidu IDL 人脸识别 SDKSNS 分享 SDK 基于 腾讯互联QQ + 微信 + 微博 的封装。GPUImage SDK 用于处理 滤镜，实时视频录制个人职责及产出 「iOS-App 研发」负责集成百度账号 SDK负责用户中心模块，变脸模块中 Gif 功能、海报功能、滤镜功能，秀场模块的需求开发与维护。负责 GPUImage 三方库的修改与优化，使之更符合项目和需求。SNS 分享 SDK 基于 腾讯互联QQ + 微信 + 微博 的封装。人脸贴纸 iOS - SDK 的制作。后应用于：熊猫直播 App，百度贴吧 App。DuBike「百度智能自行车」什么是 DuBike​ DuBike由百度深度学习实验室与清华美院共同打造，百度IDL 操刀的智能自行车OS研究计划，将以百度大脑为核心引擎，通过模块化IO，实现自行车的导航、社交、健康监控、众包骑行地图、智能推荐路线及健身计划等功能。智能自行车DuBike将由安置在车身的智能感应系统以及具有健康管理和社交功能的APP组成，将集成传感器、人工智能、自动控制、大数据分析等多项技术。DuBike 的使命​ 打造智能骑行平台方案选型「Android - App」开发语言采用 Java + C++， MVC 架构。百度地图 SDK + 百度地图在线 API 接口。Volley 网络请求框架 + Gson 模型解析。自定义 Chart View 。蓝牙 BLE 4.0 传输数据。个人职责及产出参与产品需求定义阶段讨论负责与硬件进行对接，负责 BLE 蓝牙数据包协议制定。负责提供底层蓝牙数据的解析，存储。负责 App 首页数据模块，自行车配置模块，骑行足迹模块等的需求研发。语言能力英语：读写能力 良好 | 听说能力 良好专业技能：Android 领域开发： 精通，Kotlin，Java， JNI， C++ 「语言熟悉度，按顺序排列」iOS 领域开发：精通，Swift， OC， C++ 「语言熟悉度，按顺序排列」Linux 程序：熟悉， C++"},{"title":"tag","date":"2021-06-19T08:45:43.000Z","updated":"2021-06-19T09:01:14.881Z","comments":true,"path":"tag/index.html","permalink":"http://davidxiaoshuo.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"抽象工厂模式","slug":"design_pattern/abstract_factory_pattern","date":"2021-08-18T03:02:37.000Z","updated":"2021-08-19T10:48:38.025Z","comments":true,"path":"design_pattern/abstract_factory_pattern/","link":"","permalink":"http://davidxiaoshuo.github.io/design_pattern/abstract_factory_pattern/","excerpt":"","text":"抽象工厂模式「Abstact Factory Pattern」，是围绕一个超级工厂创建其他工厂，可以说是工厂的工厂。属于创建型模式，它提供了创建对象的最佳方式。意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。主要解决：解决接口选择的问题。优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终使用一个产品族中的对象。缺点：产品族扩展非常困难，想要增加一个系列的产品，既要在抽象的 Creator 里增加代码，也要在具体的产品实现类里增加代码。具体实现定义import Cocoaprotocol ICarProducer &#123; &#125;protocol ICar: ICarProducer &#123; func drive()&#125;protocol ICarColor: ICarProducer &#123; func bodyColor()&#125;class BenzCar: ICar &#123; required init() &#123; &#125; func drive() &#123; print(\"我开的是大奔...\") &#125; &#125;class BMWCar: ICar &#123; required init() &#123; &#125; func drive() &#123; print(\"我开的是宝马...\") &#125;&#125;class MaseratiCar: ICar &#123; required init() &#123; &#125; func drive() &#123; print(\"我开的是玛莎拉蒂...\") &#125; &#125;class White: ICarColor &#123; required init() &#123; &#125; func bodyColor() &#123; print(\"车身颜色是白色的.\") &#125; &#125;class Black: ICarColor &#123; required init() &#123; &#125; func bodyColor() &#123; print(\"车身颜色是黑色的.\") &#125; &#125;class Yellow: ICarColor &#123; required init() &#123; &#125; func bodyColor() &#123; print(\"车身颜色是黄色的.\") &#125; &#125;protocol ICarFactory &#123; func createCar(type: ICar.Type) -&gt; ICar? func createCar&lt;Car: ICar&gt;() -&gt; Car? func getCarBodyColor(type: ICarColor.Type) -&gt; ICarColor? &#125;extension ICarFactory &#123; func createCar(type: ICar.Type) -&gt; ICar? &#123; nil &#125; func createCar&lt;Car: ICar&gt;() -&gt; Car? &#123; nil &#125; func getCarBodyColor(type: ICarColor.Type) -&gt; ICarColor? &#123; nil &#125;&#125;class CarFactory: ICarFactory &#123; required init() &#123; &#125; func createCar(type: ICar.Type) -&gt; ICar? &#123; if let benz = type as? BenzCar.Type &#123; return benz.init() &#125; if let bmw = type as? BMWCar.Type &#123; return bmw.init() &#125; if let maserati = type as? MaseratiCar.Type &#123; return maserati.init() &#125; return nil &#125; func createCar&lt;Car: ICar&gt;() -&gt; Car? &#123; if let benz = Car.self as? BenzCar.Type &#123; return benz.init() as? Car &#125; if let bmw = Car.self as? BMWCar.Type &#123; return bmw.init() as? Car &#125; if let maserati = Car.self as? MaseratiCar.Type &#123; return maserati.init() as? Car &#125; return nil &#125;&#125;class CarBodyColorFactory: ICarFactory &#123; required init() &#123; &#125; func getCarBodyColor(type: ICarColor.Type) -&gt; ICarColor? &#123; if let white = type as? White.Type &#123; return white.init() &#125; if let black = type as? Black.Type &#123; return black.init() &#125; if let yellow = type as? Yellow.Type &#123; return yellow.init() &#125; return nil &#125;&#125;class CarFactoryProducer &#123; class func buildCarFactory&lt;CarAbstractFactory: ICarFactory&gt;() -&gt; CarAbstractFactory? &#123; if let carFactory = CarAbstractFactory.self as? CarFactory.Type &#123; return carFactory.init() as? CarAbstractFactory &#125; if let colorFactory = CarAbstractFactory.self as? CarBodyColorFactory.Type &#123; return colorFactory.init() as? CarAbstractFactory &#125; return nil &#125; &#125;调用let carFactory: CarFactory? = CarFactoryProducer.buildCarFactory()let benz: BenzCar? = carFactory?.createCar()benz?.drive()let bmw: BMWCar? = carFactory?.createCar()bmw?.drive()let maserati: MaseratiCar? = carFactory?.createCar()maserati?.drive()let carBodyColorFactory: CarBodyColorFactory? = CarFactoryProducer.buildCarFactory()let whiteColor = carBodyColorFactory?.getCarBodyColor(type: White.self)whiteColor?.bodyColor()let blackColor = carBodyColorFactory?.getCarBodyColor(type: Black.self)blackColor?.bodyColor()let yellowColor = carBodyColorFactory?.getCarBodyColor(type: Yellow.self)yellowColor?.bodyColor()","categories":[{"name":"Pattern","slug":"Pattern","permalink":"http://davidxiaoshuo.github.io/categories/Pattern/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"},{"name":"pattern","slug":"pattern","permalink":"http://davidxiaoshuo.github.io/tags/pattern/"}]},{"title":"工厂模式","slug":"design_pattern/factory_pattern","date":"2021-08-18T03:02:37.000Z","updated":"2021-08-19T08:03:45.010Z","comments":true,"path":"design_pattern/factory_pattern/","link":"","permalink":"http://davidxiaoshuo.github.io/design_pattern/factory_pattern/","excerpt":"","text":"工厂模式「Factory Pattern」，属于创建型模式，它提供了一种创建对象的最佳方式。创建对象时，不会对使用者「客户端」暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的的对象。意图： 定义一个创建对象接口，让其子类自己决定实例化哪个工厂类，使其创建过程延迟到子类。主要解决：解决接口选择的问题。优点：调用者创建一个对象，只要知道其名称就可以了。扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以了。屏蔽产品的具体实现，调用者只关心产品的接口。缺点：每次增加一个产品，都需要增加一个具体的类和对工厂接口的实现。使得系统中类的个数成倍增加，增加了系统的复杂度和具体类的依赖性。具体实现定义import Cocoaprotocol Shape &#123; func draw()&#125;class Rectangle: Shape &#123; required init() &#123; &#125; func draw() &#123; print(\"I'm a rectangle\") &#125;&#125;class Circle: Shape &#123; required init() &#123; &#125; func draw() &#123; print(\"I'm a circle\") &#125;&#125;class ShapeFactory: Shape &#123; private var shape: Shape? class func create(type: Shape.Type) -&gt; Shape? &#123; if let rectangle = type as? Rectangle.Type &#123; return rectangle.init() &#125; if let circle = type as? Circle.Type &#123; return circle.init() &#125; return nil &#125; class func create&lt;S: Shape&gt;() -&gt; S? &#123; if let rectangle = S.self as? Rectangle.Type &#123; return rectangle.init() as? S &#125; if let circle = S.self as? Circle.Type &#123; return circle.init() as? S &#125; return nil &#125; func draw() &#123; shape?.draw() &#125;&#125;调用let rectangle: Rectangle? = ShapeFactory.create()rectangle?.draw()let circle: Circle? = ShapeFactory.create()circle?.draw()let circle2 = ShapeFactory.create(type: Circle.self)circle2?.draw()","categories":[{"name":"Pattern","slug":"Pattern","permalink":"http://davidxiaoshuo.github.io/categories/Pattern/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"},{"name":"pattern","slug":"pattern","permalink":"http://davidxiaoshuo.github.io/tags/pattern/"}]},{"title":"Swift 中元类型理解","slug":"iOS/swift_type_self","date":"2021-08-18T03:02:37.000Z","updated":"2021-08-19T08:04:15.323Z","comments":true,"path":"iOS/swift_type_self/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_type_self/","excerpt":"","text":"什么是元类型 「Metatype」元类型是指任何类型的的类型，包括类类型、结构体类型、枚举类型和协议类型。类、结构体或枚举类型的元类型，在该类型的名称后面跟 .Type；协议类型的元类型，是该协议名称后跟 .Protocol。如：类类型 SomeClass 的元类型是 SomeClass.Type;协议 SomeProtocol 的元类型是 SomeProtocol.Protocol可以使用后缀 .self 表达式将类型作为值访问。如：SomeClass.self 返回 SomeClass 本身，而不是 SomeClass 的实例。SomeProtocol.self 返回的是 SomeProtocol 本身，而不是在运行时符合 SomeProtocol 的类型的实例。class BaseClass &#123; class func printClassName() &#123; print(\"BaseClass\") &#125;&#125;class SubClass: BaseClass &#123; override class func printClassName() &#123; print(\"SubClass\") &#125;&#125;let someInstance: BaseClass = SubClass()/* | | compileTime Runtime | | To extract, use: .self type(of) Check the runtime type of someInstance use `type(of:)`: */print(type(of: someInstance) == SubClass.self) // Trueprint(type(of: someInstance) == BaseClass.self) // False /* Check the compile time type of someInstance use `is`: */print(someInstance is SubClass) // Trueprint(someInstance is BaseClass) // Truetype(of: someInstance).printClassName() // Prints \"SomeSubClass\"type(of:) 解析返回的是 Metatype 的实例，也就是一个具体的类型，用这个返回的类型，我们可以调用它的构造器或者静态属性或者方法。它返回的是一个值的动态类型。使用初始化表达式从该类型的元类型值构造一个类型的实例。对于类类型，被调用的初始化构造器必须使用 required 关键字或整个类用 final 关键字标记。class AnotherSubClass: SomeBaseClass &#123; let string: String required init(string: String) &#123; self.string = string &#125; override class func printClassName() &#123; print(\"AnotherSubClass\") &#125;&#125;let metatype: AnotherSubClass.Type = AnotherSubClass.selflet anotherInstance = metatype.init(string: \"some string\")类型 VS 元类型两者的区别在于：元类型的值为类型，用类型名加上 .self 表示。而类型的值为该类型的实例对象。如： Int.Type 的值为 Int.self, Int 的值可以为任意整数。let intMetatype: Int.Type = Int.selflet intType: Int = 10Note: SomeType.self &amp; SomeProtocol.self 表示元类型的值，而 someInstance.self 表示该实例对象本身AnyClassAnyClass 其实就是任意类类型的元类型。AnyClass 是 AnyObject.Type 的别名，而 AnyObject 是任何 class 都会默认实现的协议。public typealias AnyClass = AnyObject.Type元类型的应用场景我们经常用到的 UITableView &amp; UICollectionView 中 cell 的注册方法func register(AnyClass?, forCellReuseIdentifier: String)tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\")我们平常在使用工厂模式时的对产品类型实例的创建方法。例如","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"},{"name":"pattern","slug":"pattern","permalink":"http://davidxiaoshuo.github.io/tags/pattern/"}]},{"title":"关于多 IM 通信通道「SDK」的架构设计","slug":"architecture/im_plugin_box","date":"2021-07-02T06:46:19.142Z","updated":"2021-07-04T03:23:13.359Z","comments":true,"path":"architecture/im_plugin_box/","link":"","permalink":"http://davidxiaoshuo.github.io/architecture/im_plugin_box/","excerpt":"","text":"设计背景由于公司的主要产品是做智能硬件相关的产品。最早开始设备端是基于 Android OS 开发的。所以当时在做及时通信方案选型的时候，选择了云信 IM，来作为设备端与 App 的通信工具。后来慢慢，我们的新品「SKU」不断增多，系统也由最初的 Android OS，到 Linux，到 Atos ，不断往低成本方案演进，而且还出来了欧洲版。诸多因素导致 App 端云信 IM 已经不能担此重任，必须重新选型。基于此做出了一个 IMPluginBox 的 Framework。架构设计此 SDK 采用分层架构设计，每层的职责清晰且具有可扩展性。目前此 SDK 底层集成了: 网易云信 NIM, 腾讯云通信 TIM, 阿里云 MQTT, 三家 SDK. SDK 的架构图如下：在 iOS 中，根据 CocoaPods 的特性，可以根据具体需求，底层去集成一家或多家 SDK。如: pod 'WLIMPlugBox', '0.3.0', :subspecs =&gt; ['AliyunMQTT', 'NIM']在 Android 中，利用 gradle 的 Flavor 的特性，对各家 SDK 进行组合，可以发布多个 Library 到 Maven，App 可根据需求集成不同 Lib。如: &quot;ai.ling.lib:im-messager-nimAndAliyunMqtt:0.1.0-rc.22&quot;;业务层应答机制由于 App 需要实时掌握设备端的状态。所以需要基于 IM 需要设计出一套 ACK 机制来实现此需求。","categories":[{"name":"Architecture","slug":"Architecture","permalink":"http://davidxiaoshuo.github.io/categories/Architecture/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/tags/iOS/"}]},{"title":"iOS Runtime 上手 -","slug":"iOS/runtime","date":"2021-06-19T11:15:37.000Z","updated":"2021-07-05T14:27:18.468Z","comments":true,"path":"iOS/runtime/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/runtime/","excerpt":"","text":"什么是 RuntimeRuntime 中的专有知识解释消息框架「消息机制工作流程」消息转发消息发送 &amp; 转发总结什么是 RuntimeObjective-C 是一门动态语言，因此 OC 会将更多的操作决策从编译时和链接时推迟到运行时进行。如，在运行时才会检查变量的数据类型，在运行时才会查找要调用的具体函数。这是使得 OC 变得异常灵活。OC 这一切的基础就是基于 Runtime 来提供支持的。Apple 官方提供出一个 Runtime库，来对外暴露接口。目前存在两个版本：Runtime Versions and PlatformsRuntime 中的专有知识解释ojbc_msgSend在 bjective-C 中，消息直到运行时才会绑定到方法实现。[receiver message]；调用消息传递函数。objc_msgSend(receiver, selector)objc_msgSend(receiver, selector, arg1, arg2, ...)Class 「类」在 objc/runtime.h 中，Class「类」定义为指向 objc_class 的结构体的指针。objc_class 结构体定义如下：/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa; // objc_class 结构体的实例指针#if !__OBJC2__ Class _Nullable super_class; // 指向父类的指针 const char * _Nonnull name; // 类的名字 long version; // 类的版本信息，默认为 0 long info; // 类的信息，供运行期使用的一些位标识 long instance_size; // 该类的实例变量大小 struct objc_ivar_list * _Nullable ivars; // 该类的实例变量列表 struct objc_method_list * _Nullable * _Nullable methodLists; // 方法定义的列表 struct objc_cache * _Nonnull cache; // 方法缓存 struct objc_protocol_list * _Nullable protocols; // 遵守的协议列表#endif&#125;;Note： objc_class 结构体存放的数据称为元数据「meta data」objc_class 结构体 的第一个成员变量是 isa 指针，isa 指针 保存的是所属类的结构体的实例的指针，这里保存的就是 objc_class 结构体的实例指针，而实例换个名字就是 对象。换句话说，Class（类） 的本质其实就是一个对象，我们称之为 类对象。Object 「对象」在 objc/objc.h.h 中，Object「对象」被定义为 objc_object 结构体。结构体定义如下：/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;这里的 id 被定义为一个指向 objc_object 结构体 的指针。从中可以看出 objc_object 结构体 只包含一个 Class 类型的 isa 指针。一个 Object「对象」唯一保存的就是它所属 Class「类」 的地址。 当我们对一个对象，进行方法调用时，比如 [receiver selector];，它会通过 objc_object 结构体的 isa 指针 去找对应的 objc_class 结构体，然后在 objc_class 结构体 的 methodLists 中找到我们调用的方法，然后执行。类和对象结构的这些元素如图:Meta Class 「元类」objc_object:isa -&gt; objc_class -&gt; objc_class:isa -&gt; ???`对象「objc_object 结构体」的 isa 指针指向的是对应的类对象objc_class结构体。objc_class 结构体的 isa 指针实际上指向的的是类对象自身的 Meta Class「元类」Meta Class「元类」就是一个类对象所属的类。一个对象所属的类叫做类对象，而一个类对象所属的类就叫做元类。实例对象、类、元三者的关系isa ：水平方向上，每一级中的 实例对象 的 isa 指针 指向了对应的 类对象，而 类对象 的 isa 指针 指向了对应的 元类。而所有元类的 isa 指针 最终指向了 NSObject 元类，因此 NSObject 元类 也被称为 根源类。垂直方向上， 元类 的 isa 指针 和 父类元类 的 isa 指针 都指向了 根元类。而 根源类 的 isa 指针 又指向了自己superclass类对象 的 父类指针 指向了 父类的类对象，父类的类对象 又指向了 根类的类对象，根类的类对象 最终指向了 nil。元类 的 父类指针 指向了 父类对象的元类。父类对象的元类 的 父类指针指向了 根类对象的元类，也就是 根元类。而 根元类 的 父亲指针 指向了 根类对象，最终指向了 nil。Method「方法」在 objc/runtime.h 中， objc_method 结构体定义如下：/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; // 方法类型 IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; OBJC2_UNAVAILABLE;SEL &amp; IMPtypedef struct objc_selector *SEL;struct objc_selector &#123; char *name; OBJC2_UNAVAILABLE; char *types; OBJC2_UNAVAILABLE;&#125;;IMP 可以理解为函数指针，指向了最终的实现。SEL 与 IMP 的关系非常类似于 HashTable 中 key 与 value 的关系。OC 中不支持函数重载的原因就是因为一个类的方法列表中不能存在两个相同的 SEL 。但是多个方法却可以在不同的类中有一个相同的 SEL，不同类的实例对象执行相同的 SEL 时，会在各自的方法列表中去根据 SEL 去寻找自己对应的IMP。这使得OC可以支持函数重写。method_types方法类型 method_types 是个字符串，用来存储方法的参数类型和返回值类型。消息转发「消息机制工作流程」当一个对象 sender 调用代码[receiver message];的时候，实际上是调用了runtime的objc_msgSend函数，所以OC的方法调用并不像C函数一样能按照地址直接取用，而是经过了一系列的过程。这样的机制使得 runtime 可以在接收到消息后对消息进行特殊处理，这才使OC的一些特性譬如：给 nil 发送消息不崩溃，给类动态添加方法和消息转发等成为可能。也正因为每一次调用方法的时候实际上是调用了一些 runtime 的消息处理函数，OC的方法调用相对于C来说会相对较慢，但 OC 也通过引入 cache 机制来很大程度上的克服了这个缺点。动态消息解析通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 unrecognized selector sent to instance，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 unrecognized selector sent to instance.可以利用 2、3 中的步骤实现对接受消息对象的转移，可以实现“多重继承”的效果。参考资料https://juejin.cn/post/6844903878794706957https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.htmlhttps://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW2https://github.com/opensource-apple/objc4/tree/master/runtime","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift, runtime","slug":"swift-runtime","permalink":"http://davidxiaoshuo.github.io/tags/swift-runtime/"}]},{"title":"Swift 静态 vs 动态 分派","slug":"iOS/swift_dynamic","date":"2021-06-19T11:15:37.000Z","updated":"2021-06-21T09:55:36.018Z","comments":true,"path":"iOS/swift_dynamic/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_dynamic/","excerpt":"","text":"前言在讨论关于 Swift 的静态分派和动态分派之前，需要先弄清基本概念。值类型 和 引用类型: 值类型，存储在栈中；引用类型存储在堆中。在 Swift 中，struct、enum 属于值类型，存储在栈上，class 属于引用类型，存储在堆上。值类型，引用类型都支持静态调度，但是动态调度只有引用类型是可以支持的。调度技术实际上是有 4 种的：Inline 「Fastest」Static DispatchVirtual DispatchDynamic Dispatch 「Slowest」静态 VS 动态何为 静态 和 动态 分派：在执行方法时，首先要做的事就是找到方法，而能够在编译期就确定方法的方式就叫做静态分派，而无法在编译期确定，只能在运行时确定执行方法的方式就是动态分派。Static Dispatch有时称为直接调度。如果方法是静态分派的，编译器可以在编译时定位指令所在的位置。因此，当调用该函数时，系统会直接跳转到该函数的内存地址执行操作。这种直接行为导致执行速度非常快，并且还允许编译器执行各种优化，例如内联。事实上，由于巨大的性能提升，在编译管道中有一个阶段，在该阶段编译器尝试使函数静态（如果适用）。这种优化称为去虚拟化。Dynamic Dispatch使用动态调度只有在运行时才知道要执行的是哪个方法。Swift 提供了两种实现动态的方式：表调度「Table」和消息调度「Message」。Table Dispatch基于继承关系的多态实现「Inheritance-Based Polymorphism」，一个类与一个所谓的虚拟表相关联，该虚拟表「V-Table」包含一个函数指针数组，该数组指向对应于该类的实际实现。请注意，V-Table 是在编译时构建的。因此，与静态调度相比，只有两条额外的指令（读取和跳转）。所以理论上分派应该很快。[V-Table 内存结构]没有继承或引用语义的多态 「Protocol-Types」, 管理这个协议类型的方法表是 Protocol Witness Table 简称 PWT.[PWT 内存结构]Message Dispatch事实上，是 Objective-C 提供了这种机制（有时，它被称为消息传递），而 Swift 代码只是使用了 Objective-C 运行时库。每次调用 Objective-C 方法时，调用都会传递给 objc_msgSend，后者处理查找。从技术上讲，该过程从给定的类开始，并迭代类层次结构以提取实现。消息调度是三者中最动态的。作为权衡，虽然查找性能由缓存机制保护，但解析实现的成本可能会有点昂贵。这种机制是 Cocoa 框架的基石。查看 Swift 的源码，你会发现 KVO 是使用 swizzling 实现的。Swift 中实现 Message Dispatch, 需要在方法前添加 @objc dynamic。 在 Swift 4.0 之前，@objc 是被隐式添加的，在 4.0 以后，需要我们手动添加。Swift 中的方法分派 caseNote: 带有 final 关键字的方法属于静态分派；普通扩展中的「不被 @objc, dynamic 描述的」方法也属于静态分派。extension Animal &#123; func eat() &#123; &#125; @objc dynamic func getWild() &#123; &#125;&#125;class Dog: Animal &#123; override func eat() &#123; &#125; // Compiled error! @objc dynamic override func getWild() &#123; &#125; // Ok :)&#125;protocol Noisy &#123; func makeNoise() -&gt; Int // Table Dispatch&#125;extension Noisy &#123; func makeNoise() -&gt; Int &#123; return 0 &#125; // Table Dispatch func isAnnoying() -&gt; Bool &#123; return true &#125; // Static Dispatch, extension 中普工方法&#125;class Animal: Noisy &#123; func makeNoise() -&gt; Int &#123; return 1 &#125; // Table Dispatch func isAnnoying() -&gt; Bool &#123; return false &#125; // Table Dispatch @objc func sleep() &#123; &#125; // Table Dispatch&#125;extension Animal &#123; func eat() &#123; &#125; // Static Dispatch, extension 中普工方法 @objc func getWild() &#123; &#125; // \b\bMessage Dispatch&#125;参考Method dispatch in Swiftmaking-the-value-witness-table-reference-relative","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"}]},{"title":"iOS 线程使用总结 1","slug":"iOS/thread_summary_1","date":"2021-06-19T11:15:37.000Z","updated":"2021-07-05T09:15:35.552Z","comments":true,"path":"iOS/thread_summary_1/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/thread_summary_1/","excerpt":"","text":"前言：下面出现的练习 code 在 SwiftyThreadExercise一些基本概念进程：在系统中运行的一个应用程序，每个进程间是独立的。每个进程均运行在其专有的且受保护的内存空间中。线程：一个进程「程序」的所有任务都是在线程中执行的，每个进程至少有一个线程「主线程」。主线程：一个 iOS 程序运行后，会默认开启一条线程，称之为“主线程” 或 “UI 线程”。主线程用来处理 UI 事件（如：点击，滚动，拖拽等事件），也是用来显示/刷新 UI 界面。多线程：一个进程可以开启多条线程，多条线程可以并行「同时」执行不同的任务，多线程并发「同时」执行，其实就是 CPU 快速的在多条线程间调度「切换」。同步：在当前线程，按照先后顺序执行，不开启新的线程。异步：在当前线程，开启一个或多个线程，可不按照顺序执行。队列：承载线程任务的一个容器。并发：线程可以同时一起执行。串行：线程执行顺序，只能按照先后顺序，依次执行。iOS 中线程实现方案pthread: 跨平台/可移植；线程生命周期需要人为管理。 Note: 暂不讨论, 理由：几乎用不到NSThread: 使用面向对象；相比 pthread 更加直观操作线程对象；线程生命周期需要人为管理。CCD: Grand Central Dispatch, 充分利用多核，允许多任务在队列总串行或并行的执行。自动线程的生命周期。旨在替代 NSThread。NSOperation: 基于 CGD，比 GCD 多了一些实用功能；更加面向对象；线程生命周期需要人为管理。NSThreadNSThread 有以下几种状态：新建「创建」：进入就绪状态 -&gt; 运行状态。 当线程任务执行完毕，自动进入死亡状态。就绪状态 runnable。强制停止线程，cancel。运行，running。阻塞状态。死亡状态。exit, 一旦线程停止「死亡」，就不能再次开启任务了。/// NSThread 启动方式/// 动态启动，创建之后需要手动调用 start 方法let thread1 = Thread(target: self, selector: #selector(onThreadRun), object: nil)thread1.start()/// 静态启动，创建之后自动启动线程。/// ①：通过 selector 方式实现Thread.detachNewThreadSelector(#selector(onThreadRun), toTarget: self, with: nil)/// ②：通过 block 方式实现Thread.detachNewThread &#123; &#125;/// 隐式开启，`performSelector` 是 NSThread 针对 NSObject 的一个扩展方法。/// ①：开启一个后台线程执行self.performSelector(inBackground: #selector(onThreadRun), with: nil)/// ②：在主线程执行self.performSelector(onMainThread: #selector(onThreadRun), with: nil, waitUntilDone: false)/// ③：在指定线程执行self.perform(#selector(onThreadRun), on: thread, with: nil, waitUntilDone: true)/// NSThread 中常用的方法/// 获取当前线程let currentThread = Thread.current/// 获取主线程let mainThread= Thread.main/// 是否为主线程let isMainThread = Thread.isMainThread/// 线程是否在运行中Thread.current.isExecuting/// 退出线程Thread.exit()GCDGCD 全称 Grand Central Dispatch, 其有如下优势：多核并行运算的解决方案自动利用更多的 CPU 内核（如双核、四核）自动管理线程的生命周期程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码任务 &amp; 队列任务，就是要执行指定需求的代码块。它有两种执行方式：同步执行「sync」: 在当前线程执行任务，不会开启新的线程，必须等到任务执行完毕，dispatch 才会返回，才可以继续往下执行。异步执行「async」： 可以在新的线程中执行任务「不一定会开启新的线程」。dispatch 会立即返回，继续往下执行，任务代码块在后台异步执行。队列，任务的管理方式。分为串行对列 &amp; 并行队列两种，都是按照 FIFO 「先进先出」原则依次触发任务。串行队列，所有任务都在同一个线程中执行，一个任务执行完毕后，才开始执行下一个任务。并行队列，可以在多条线程执行任务，当一个任务放到指定的线程开始执行时，下一个任务就可以开始执行了。队列有以下几种类型：同步并发：没有开启新线程，串行执行任务同步串行：没有开启新线程，串行执行任务同步主队列：没有开启新线程，串行执行任务异步并发：开启新线程，并发执行任务异步串行：开启新线程，串行执行任务异步主队列：没有开启新线程，串行执行任务特有队列/// DispatchQueue.main 特殊串行主队列，无论是同步「sync」还是异步「async」，都是执行在主线程，async 虽然不阻塞主线程，但由于在一个队列上，DispatchQueue.main 只有在执行完当前任务后，才会执行下一个任务「async」。/// Note: 一定要在主线程执行和 UI 有关的操作。/// 异步主队列，串行执行任务，不阻塞当前线程DispatchQueue.main.async &#123; &#125;/// 同步主队列，串行执行任务，阻塞当前线程。嵌套 sync &#123;&#125; ，可能会导致死锁。DispatchQueue.main.sync &#123; &#125;/// DispatchQueue.global(), 全局并发队列, 全局只有一个。/// 异步全局队列, 串行执行任务，不阻塞当前线程DispatchQueue.global().async &#123; &#125;/// 同步全局队列，串行执行任务，阻塞当前线程。DispatchQueue.global().sync &#123; &#125;串行队列/// 同步：/// 默认即是串行队列let queue = DispatchQueue(label: \"ai.studio.david.queue.1\")print(\"queue execute before, current thread = \\(Thread.current)\")queue.sync &#123; (0...5).forEach &#123; print(\"index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;queue.sync &#123; (0...5).forEach &#123; print(\"index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;print(\"queue execute after, current thread = \\(Thread.current)\")// queue execute before, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 0, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 1, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 2, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 3, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 4, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 1, index = 5, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 0, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 1, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 2, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 3, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 4, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue 2,index = 5, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;// queue execute after, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;/// 分析：/// `sync`,同步执行，阻塞当前线程。/// 结果按照顺序一个一个执行，同步执行会一直等待，等一个任务执行在执行下一个任务。/// 注意：主线程中的 `before` &amp; `after` 两个打印，线程信息结果跟串行队列中的是相同的。这说明，队列中的同步任务在执行时，系统给他们分配的线程是主线程。/// 异步：/// 默认即是串行队列let queue = DispatchQueue(label: \"ai.studio.david.queue.1\")print(\"queue execute before, current thread = \\(Thread.current)\")queue.async &#123; (0...5).forEach &#123; print(\"queue 1, index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;queue.async &#123; (0...5).forEach &#123; print(\"queue 2,index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;print(\"queue execute after, current thread = \\(Thread.current)\")// queue execute before, current thread = &lt;NSThread: 0x600003cbc540&gt;&#123;number = 1, name = main&#125;// queue execute after, current thread = &lt;NSThread: 0x600003cbc540&gt;&#123;number = 1, name = main&#125;// queue 1, index = 0, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 1, index = 1, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 1, index = 2, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 1, index = 3, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 1, index = 4, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 1, index = 5, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 0, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 1, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 2, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 3, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 4, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;// queue 2,index = 5, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;/// 分析：`async`, 异步不阻塞当前线程/// 由于是串行队列，任务按照 FIFO 原则，依次执行。/// Note: 创建队列时的 `label` 参数，不等同于 NSThread 中的 name 属性，`label` 用于在调试工具(如Instruments、样本、stackshots和崩溃报告)中惟一地标识队列。命名风格采用反向 DNS 命名风格(com.example.myqueue)。并发队列/// 同步，并发队列let queue = DispatchQueue(label: defaultQueueLabel, attributes: .concurrent)print(\"queue execute before, current thread = \\(Thread.current)\")queue.sync &#123; (0...5).forEach &#123; print(\"queue 1, index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;print(\"queue execute middle, current thread = \\(Thread.current)\")queue.sync &#123; (0...5).forEach &#123; print(\"queue 2,index = \\($0), current thread = \\(Thread.current)\") &#125;&#125;print(\"queue execute after, current thread = \\(Thread.current)\")// queue execute before, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 0, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 1, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 2, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 3, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 4, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 1, index = 5, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue execute middle, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 0, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 1, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 2, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 3, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 4, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue 2,index = 5, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;// queue execute after, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;/// 分析：/// 并发队列执行同步任务和在主线程执行操作没有区别。`sync` 会将当前线程固定住，让当前线程等待执行完成后才能执行后面的任务。/// 异步，并发队列let queue = DispatchQueue(label: defaultQueueLabel, attributes: .concurrent) print(\"queue execute before, current thread = \\(Thread.current)\")(0..&lt;1000).forEach &#123; print(\"index = \\($0), current thread = \\(Thread.current)\")&#125;queue.async &#123; print(\"task1, current thread = \\(Thread.current)\") &#125;queue.async &#123; print(\"task2, current thread = \\(Thread.current)\") &#125;queue.async &#123; print(\"task3, current thread = \\(Thread.current)\") &#125;queue.async &#123; print(\"task4, current thread = \\(Thread.current)\") &#125;queue.async &#123; print(\"task5, current thread = \\(Thread.current)\") &#125;print(\"queue execute after, current thread = \\(Thread.current)\") // queue execute before, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;// index = 0, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;// ···// index = 999, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;// task1, current thread = &lt;NSThread: 0x6000002e10c0&gt;&#123;number = 7, name = (null)&#125;// queue execute after, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;// task2, current thread = &lt;NSThread: 0x6000002fc300&gt;&#123;number = 6, name = (null)&#125;// task3, current thread = &lt;NSThread: 0x6000002e02c0&gt;&#123;number = 8, name = (null)&#125;// task5, current thread = &lt;NSThread: 0x6000002e10c0&gt;&#123;number = 7, name = (null)&#125;// task4, current thread = &lt;NSThread: 0x6000002a9480&gt;&#123;number = 5, name = (null)&#125;/// 分析：/// 异步并发队列，不阻塞当前线程. 异步任务是否开启线程，根据系统资源和任务完成时间决定是否重用线程。/// 虽然异步并发队列不阻塞当前线程，但是异步队列任务开始执行有可能会优先于当前线程的任务执行。其他方法/// 延迟执行/// 当前线程延迟 2s 后执行任务self.perform(#selector(onDelayHandler), with: nil, afterDelay: 2)/// 主线程延迟 2s 后执行任务DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; &#125;/// 全局队列延迟 2s 后执行任务DispatchQueue.global().asyncAfter(deadline: .now() + 2) &#123; &#125;/// 通过 timer 延迟 2s 后执行任务Timer.scheduledTimer(timeInterval: 2, target: self, selector: #selector(onDelayHandler), userInfo: nil, repeats: false)/// 快速迭代遍历，阻塞当前线程，index 是无序的DispatchQueue.concurrentPerform(iterations: 10) &#123; index in &#125;NSOperation &amp; NSOperationQueueNSOperation &amp; NSOperationQueue 是苹果对 GCD 的封装NSOperation &amp; NSOperationQueue 分别相当于 GCD 的任务和队列NSOperation 是一个抽象类，可以使用其子类 BlockOperation, 当然也可以自定义子类NSOperationQueue 支持 暂停、恢复、取消操作。这些操作，都是对后面未执行的任务进行操作，不会影响当前正在进行的任务，且 取消 不可以恢复。NSOperation 实现多线程步骤创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。创建队列：创建 NSOperationQueue 对象。将操作加入到队列中：将 NSOperation 对象添加到NSOperationQueue 对象中。之后，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。BlockOperation 的使用let blockOperation = BlockOperation &#123; print(\"operation1, block1, current thread = \\(Thread.current)\")&#125;blockOperation.start()// operation1, block1, current thread = &lt;NSThread: 0x600003e303c0&gt;&#123;number = 1, name = main&#125;/// 分析：/// 在仅使用 BlockOperation，不将其加入到 OperationQueue 时，block 可能会直接当前线程运行，是否开启新的线程，由系统资源决定。// -----------------------------------------------------------------------------------------------------/// BlockOperation 还提供了 addExecutionBlock 的方法let blockOperation = BlockOperation &#123; print(\"operation1, block1, current thread = \\(Thread.current)\")&#125;blockOperation.addExecutionBlock &#123; print(\"operation1, block2, current thread = \\(Thread.current)\")&#125;blockOperation.addExecutionBlock &#123; print(\"operation1, block3, current thread = \\(Thread.current)\")&#125;blockOperation.start()// operation1, block1, current thread = &lt;NSThread: 0x6000034a0680&gt;&#123;number = 1, name = main&#125;// operation1, block2, current thread = &lt;NSThread: 0x6000034ad2c0&gt;&#123;number = 6, name = (null)&#125;// operation1, block5, current thread = &lt;NSThread: 0x6000034a84c0&gt;&#123;number = 5, name = (null)&#125;// operation1, block3, current thread = &lt;NSThread: 0x6000034fc0c0&gt;&#123;number = 7, name = (null)&#125;// operation1, block4, current thread = &lt;NSThread: 0x6000034ad2c0&gt;&#123;number = 6, name = (null)&#125;/// 分析：/// addExecutionBlock 添加的任务，是否开启新线程，由系统决定，每次执行结果可能不太一样。/// 任务的执行顺序也是不确定的NSOperation 自定义子类可以通过实现 main 方法来自定义实现一个 NSOperation 的子类。class CustomOperation: Operation &#123; override func main() &#123; var isRunning = true var autoincrement: Int = 0 while isRunning &#123; if isCancelled &#123; isRunning = false break &#125; if autoincrement &gt;= 100 &#123; isRunning = false break &#125; print(\"current value = \\(autoincrement), current thread = \\(Thread.current)\") autoincrement += 1 &#125; &#125;&#125;NSOperationQueueNSOperationQueue 有两种队列形式：主队列 &amp; 自定义队列主队列：凡是添加到主队列中的操作，都会放到主线程中执行自定义队列：操作自动放到子线程中执行，同时包含了：串行、并发功能。let mainQueue = OperationQueue.mainlet customQueue = OperationQueue()添加任务到队列中let operationQueue = OperationQueue()/// 最大并发数，它有默认最大并发，其值根据当前系统换件决定。/// 当 maxConcurrentOperationCount = 1 时，是串行，operationQueue.maxConcurrentOperationCount = OperationQueue.defaultMaxConcurrentOperationCountlet blockOperation = BlockOperation &#123; print(\"operation1, block1, current thread = \\(Thread.current)\")&#125;operationQueue.addOperation(blockOperation)/// 分析：/// 将 BlockOperation 添加到 OperationQueue 中后，系统将不在当前线程执行，而是开启新的线程// -----------------------------------------------------------------------------------------------------/// 通过 addDependency 设置依赖关系，保证执行顺序blockOperation.addDependency(blockOperation2)operationQueue.addOperation(blockOperation)operationQueue.addOperation(blockOperation2)/// 分析：先执行 blockOperation2，再执行 blockOperation","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift，Objective-C","slug":"swift，Objective-C","permalink":"http://davidxiaoshuo.github.io/tags/swift，Objective-C/"}]},{"title":"Swift 总结之属性重写 「override」","slug":"iOS/swift_override_property","date":"2021-06-18T09:39:07.176Z","updated":"2021-06-19T09:08:06.094Z","comments":true,"path":"iOS/swift_override_property/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_override_property/","excerpt":"","text":"import Cocoaclass Student &#123; // 存储属性 var age: Int = 0 var chineseScore: Double = 0.0 var englishScore: Double = 0.0 // 计算属性 var averageScore: Double &#123; // 访问（获取）调用get get&#123; return (chineseScore + englishScore) / 2 &#125; // 设置值的时候 set&#123; print(\"set\\(newValue)\") // 千万不要在这里设置值 会死循环 外部参数起名字 newvalue // self.averageScore = newValue &#125; &#125; // 只读计算属性 var averageScore2: Double &#123; return (chineseScore + englishScore) / 2 &#125; // 类属性, 不能被重写 static var couseCount = 3 // 懒加载属性 lazy var courses: [String] = &#123; ()-&gt;[String] in print(\"懒加载属性\") return [\"java\", \"html\", \"swift\"] &#125;() // 属性观察器-有的属性很重要，我希望关注每一次赋值的变化。 // 验证 willSet 和 didSet 作用 // 内置变量：newValue oldValue var name: String = \"tt\" &#123; // newValue willSet&#123; print(\"父类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"父类 didSet 被调用, oldValue\\(oldValue)\") &#125; &#125; &#125;// 属性的继承与重写class SeniorStudent : Student&#123; private var _chineseScore: Double = 0.0 // 子类都可以通过提供getter和setter对属性进行重写 // 重写后，存储属性变为计算属性 override var chineseScore: Double&#123; get &#123; return _chineseScore &#125; set &#123; _chineseScore = newValue &#125; &#125; // 不可以将继承来的读写属性重写为只读属性 override var averageScore: Double&#123; get &#123; return 90.5 &#125; set&#123; &#125; &#125; // 如果父类已经添加了属性观察器，当属性发生变化时，父类与子类都会得到通知 override var name:String &#123; // newValue willSet&#123; print(\"子类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"子类 didSet 被调用,oldValue\\(oldValue)\") &#125; &#125; /// 懒加载属性，重写后变为计算属性 override var courses: [String] &#123; get &#123; return [\"swift\", \"OC\"] &#125; set &#123; &#125; &#125; override var averageScore2: Double &#123; return 96.1 &#125;&#125;let student = SeniorStudent()student.chineseScore = 91print(student.chineseScore)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"}]},{"title":"Swift 总结之关键字","slug":"iOS/swift_keyword_summary","date":"2021-06-16T08:31:25.746Z","updated":"2021-06-21T06:25:52.731Z","comments":true,"path":"iOS/swift_keyword_summary/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_keyword_summary/","excerpt":"","text":"声明式关键字Keyword： classDescription： Swift 语言中一种构造体「数据类型」，它具有以下特性：一个类允许另一个类进行继承，形成父子关系。支持类型转换「type-casting」，允许在运行时，检查 &amp; 指定一个类的实际类型。支持实现协议「protocol」。支持 deinit 析构函数，并且在销毁前可以释放所有资源。支持引用计数，允许多个引用指向同一个实例。不支持默认成员初始化构造器「memberwise initializer」。属于引用类型，存储在堆内存中Keyword： structDescription：与 class 一样，也是 Swift 语言中一个重要的构造体「数据类型」，它具有以下特性：支持实现协议支持默认成员初始化构造器「memberwise initializer」。不支持类型转换「type-casting」不支持 deinit析构函数内部方法修改属性时，需要在方法上添加 mutating 关键字属于值类型，存储在栈内存中Keyword：enumDescription：Swift 中的一种数据类型，它是一组有共同特性的数据的集合。它具有以下特性：支持实现协议支持初始化方法「构造方法」内部方法修改属性时，需要在方法上添加 mutating 关键字enum Barcode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125;Keyword：protocolDescription：协议定义了适合特定任务或功能的方法、属性。然后，类、结构或枚举可以采用该协议，以提供这些要求的实际实现。任何满足协议要求的类型都被称为符合该协议。除了指定符合类型必须实现的要求之外，您还可以扩展协议以实现其中一些要求或实现符合类型可以利用的附加功能。详见protocol SomeProtocol &#123; // protocol definition goes here&#125;Keyword： extensionDescription：向现有类、结构、枚举或协议类型添加新功能。这包括扩展您无法访问原始源代码的类型的能力（称为追溯建模）。扩展类似于 Objective-C 中的类别。 （与 Objective-C 类别不同，Swift 扩展没有名称。）详见在 swift 中 extension 有以下具体能力：添加计算实例属性或计算类型属性定义实例方法和类型方法提供新的构造函数定义下标定义和使用新的嵌套类型实现现有需要实现的协议Keyword：initDescription: class, struct, enum 的构造方法。enum Gender: RawRepresentable &#123; typealias RawValue = String case male case female var rawValue: String &#123; switch self &#123; case .male: return \"male\" case .female: return \"female\" &#125; &#125; init?(rawValue: String) &#123; switch rawValue &#123; case \"male\": self = .male case \"female\": self = .female default: return nil &#125; &#125;&#125;struct ClassInfo &#123; var grade: Int var classNum: Int&#125;class Student &#123; var name: String var gender: Gender var classInfo: ClassInfo init(name: String, gender: Gender, classInfo: ClassInfo) &#123; self.name = name self.gender = gender self.classInfo = classInfo &#125;&#125;Keyword： deinitDescription：class 的析构函数，每个类只允许有一个析构函数。析构函数在类实例释放前自动调用，不允许手动调用。超类的析构器由子类继承，在子类析构函数调用结束时，自动调用父类析构函数。 父类的析构器总会被调用，即使子类没有实现析构函数。实际开发中，我们可以通过 deinit 来观察类实例是否被释放。deinit &#123; // perform the deinitialization&#125;Keyword：convenienceDescription: convenience init 是类中次要的，辅助型的构造器，可以调用便利构造来调用同一个类中的指定的构造器，并且为其提供默认值，class Person: NSObject &#123; var age: Int var name: String init(age:Int, name: String) &#123; self.age = age; self.name = name; &#125; convenience init(age: Int, firstName: String, lastName: String) &#123; self.init(age:age, name:firstName+lastName); &#125; convenience init(age: Int, firstName: String, lastName: String, height: CGFloat) &#123; self.init(age: age, firstName: firstName, lastName: lastName); &#125;&#125;class Father: Person &#123; var address: String init(age: Int, name: String, address: String) &#123; self.address = address; super.init(age: age, name: name); &#125; convenience init(age: Int, firstName: String, lastName: String, address: String) &#123; self.init(age: age,name: firstName + lastName, address: address); &#125;&#125;Keyword：requiredDescription: 在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器class SomeClass &#123; var str: String required init(str: String) &#123; self.str = str &#125;&#125;class SomeSubclass: SomeClass &#123; required init(str: String) &#123; super.init(str: str) &#125; init(i: Int) &#123; super.init(str: String(i)) &#125;&#125;var SomeSubclass(str:\"Hello Swift\")Keyword：importDescription: 包导入。 详见import &lt;#module#&gt;import &lt;#kind#&gt; &lt;#module.symbol#&gt;import &lt;#module.submodule#&gt;Keyword： typealiasDescription：typealias 是特定类型的别名。换句话说，类型别名是在你的代码库里插入现有类型的另一个名称。详见typealias Money = IntKeyword: associatedtypeDescription: 关联类型定义。在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。详见Keyword：letDescription：定义一个常量。let constantString = \"hello world!\"Keyword：varDescription: 定义一个变量。var variableString = \"hello my world!\"variableString = \"hello your world!\"Keyword： funcDescription：方法定义。详见func greet(person: String) -&gt; String &#123; let greeting = \"Hello, \" + person + \"!\" return greeting&#125;Keyword：inoutDescription: inout是按值传递，然后再写回原变量，而不是按引用传递。func inc(inout i: Int) &#123; ++i&#125;var x = 0inc(&amp;x)print(x) // 输出结果：“1”func inc(inout i: Int) -&gt; () -&gt; Int &#123; return &#123; ++i &#125; // 闭包中截获inout参数i&#125;var x = 0let f = inc(&amp;x)print(f()) // 输出结果：“1”print(x) // 输出结果：“0”。Keyword：overrideDescription: 属性、方法重写需要用 override修饰。 属性重写参考Keyword: finalDescription：可以在class、func和var前修饰。class Parent &#123; final func method1() &#123; //权限验证（必须执行） //..... method2() //下面是日志记录（必须执行） //.......... &#125; func method2()&#123; //父类的实现 //...... &#125;&#125;class Child : Parent &#123; //只能重写父类的method2方法，不能重写method1方法 override func method2() &#123; //子类的实现 //...... &#125;&#125;Keyword: mutatingDescription: 见Keyword：nonmutatingprotocol Settings &#123; subscript(key: String) -&gt; AnyObject? &#123; get nonmutating set &#125;&#125;struct Test2 &#123; var b: Int &#123; get &#123; return 2 &#125; nonmutating set &#123; print(\"\\(newValue)\") &#125; &#125;&#125;/// 由于这里 t 是常量，如果 setter 中不是使用 nonmutating，编译器会报错/// Cannot assign to property: 't' is a 'let' constantlet t = Test2()t.b = 3print(t.b)Keyword： dynamicDescription: 指明编译器不会对类成员或者函数的方法进行内联或虚拟化。这意味着对这个成员的访问是使用 Objective-C 运行时进行动态派发的（代替静态调用）。 参考1，参考2class Person &#123; //隐式指明含有 \"objc\" 属性 //这对依赖于 Objc-C 黑魔法的库或者框架非常有用 //比如 KVO、KVC、Swizzling dynamic var name:String? &#125;属性声明相关的关键字Keyword： lazy，set， get, willSet, didSet// 懒加载属性lazy var courses: [String] = &#123; ()-&gt;[String] in print(\"懒加载属性\") return [\"java\", \"html\", \"swift\"]&#125;()// 计算属性var averageScore: Double &#123; // 访问（获取）调用get get&#123; return (chineseScore + englishScore) / 2 &#125; // 设置值的时候 set&#123; print(\"set\\(newValue)\") // 千万不要在这里设置值 会死循环 外部参数起名字 newvalue // self.averageScore = newValue &#125;&#125;// 属性观察器-有的属性很重要，我希望关注每一次赋值的变化。// 验证 willSet 和 didSet 作用// 内置变量：newValue oldValuevar name: String = \"tt\" &#123; // newValue willSet&#123; print(\"父类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"父类 didSet 被调用, oldValue\\(oldValue)\") &#125;&#125;权限控制关键字Keyword：openDescription：公开权限，最高权限级别。可以被其他 Module 访问、继承、复写。只能用于类和类的成员Note：由于其具有复写的特性，而 let「常量」属性隐式为 final, 不可复写，所以 open 不能应用到 let 属性上。open class Person &#123; open var name: String? open func talking() -&gt; String &#123; return \"\" &#125;&#125;Keyword: publicDescription：公有访问权限, 类或者类的公有属性或者公有方法可以从文件或者模块的任何地方进行访问. 一个App就是一个模块, 一个第三方API、第三方框架等都是一个完整的模块, 这些模块如果要对外留有访问的属性或者方法, 就应该使用public的访问权限. public的权限在Swift 3.0后无法在其它模块被复写方法/属性或被继承.public class Person &#123; public var name: String? public let uid: String = UUID().uuidString public func talking() -&gt; String &#123; return \"\" &#125;&#125;Keyword: internalDescription: 在模块内部可以访问, 超出模块内部就不可被访问了. 在Swift中属隐式权限，如果不特别设置权限级别，默认即为 internalKeyword：fileprivateDescription：文件私有访问权限, 被fileprivate修饰的类或者类的属性或方法可以在同一个物理文件中访问. 如果超出该物理文件, 那么有这fileprivate访问权限的类、属性和方法就不能被访问了.class ClassModel &#123; init() &#123; let student = Student() let studentName = student.name //只有此文件内可访问 &#125;&#125;fileprivate class Student &#123; fileprivate var name: String = \"\" private var age: Int = 12 // 外部不可访问&#125;Keyword：privateDescription：私有访问权限, 被private修饰的类或者类的属性或方法可以在同一个物理文件中的同一个类型(包含extension)访问. 如果超出物理文件或不属于同一类型, 那么有着private访问权限的属性和方法就不能被访问.private class Student &#123; private let uid = UUID().uuidString private var name: String? private func taking() -&gt; String &#123; return \"hello\" &#125;&#125;类型范围作用域关键字Keyword: staticDescription: 用来修饰类型「class / struct / enum」的属性或方法。static具有以下特性：static可以修饰计算属性、存储属性、类型方法。在 protocol中，如果需要，要使用 static 进行修饰。static 修饰的属性/方法具有隐式的 final 特性，因此不能够继承。静态属性具有实例内存共享特性struct Point &#123; let x: Double let y: Double // 存储属性 static let zero = Point(x: 0, y: 0) // 计算属性 static var ones: [Point] &#123; return [ Point(x: 1, y: 1), Point(x: -1, y: 1), Point(x: 1, y: -1), Point(x: -1, y: -1) ] &#125; // 类型方法 static func add(p1: Point, p2: Point) -&gt; Point &#123; return Point(x: p1.x + p2.x, y: p1.y + p2.y) &#125; &#125;Keyword：classDescription：只能用来修饰类方法，计算属性。在 protocol 中，不可以使用 class 来修饰。class 修饰的类方法，可以继承。class MyClass &#123; //修饰计算属性 class var age: Int &#123; return 10 &#125; // 修饰类方法 class func testFunc() &#123; &#125;&#125;逻辑运算关键字Keyword： if，elselet number = 1if number &gt; 1 &#123; print(\"greating many times\")&#125; else if number &lt; 1 &#123; print(\"not greating\")&#125; else &#123; print(\"greating one times\")&#125;Keyword：forlet numbers: [Int] = [1, 2]for index in 0..&lt;numbers.count &#123; print(\"number = \\(numbers[index])\")&#125;Keyword: switch， case， default，fallthroughenum GenderValue: Int &#123; case male case female&#125;switch gender &#123; case .male: print(\"The gender value is \\(.male.rawValue)\") case .female: print(\"The gender value is \\(.female.rawValue)\") default: break&#125;var index = 10switch index &#123; case 100 : print( \"index 的值为 100\") fallthrough case 10,15 : print( \"index 的值为 10 或 15\") fallthrough case 5 : print( \"index 的值为 5\") default : print( \"默认 case\")&#125;// index 的值为 10 或 15// index 的值为 5Keyword: repeat，while// 在使用循环的判断条件之前，先执行一次循环中的代码。repeat &#123; // do something&#125; while n &gt; 0while n &lt; 0 &#123; // do something &#125;Keyword：whereDescription：可以用来设置约束条件、限制类型，让代码更加简洁、易读。 参考/// switch语句中使用scores.forEach &#123; switch $0 &#123; case let x where x&gt;=60: print(\"及格\") default: print(\"不及格\") &#125;&#125; /// for语句中使用for score in scores where score&gt;=60 &#123; print(\"这个是及格的：\\(score)\")&#125;/// 在 do catch 里面使用enum ExceptionError: Error &#123; case httpCode(Int)&#125; func throwError() throws &#123; throw ExceptionError.httpCode(500)&#125; do&#123; try throwError()&#125;catch ExceptionError.httpCode(let httpCode) where httpCode &gt;= 500 &#123; print(\"server error\")&#125;catch &#123; print(\"other error\")&#125;/// 与协议结合protocol aProtocol&#123;&#125; //只给遵守myProtocol协议的UIView添加了拓展extension aProtocol where Self: UIView &#123; func getString() -&gt; String&#123; return \"string\" &#125;&#125;/// 可以在 associatedtype 后面声明的类型后追加 where 约束语句protocol Sequence &#123; associatedtype Element where Self.Element == Self.Iterator.Element // ...&#125;/// Sequence，Collection 同样新增了 where 语句约束extension Sequence where Element: Numeric &#123; var sum: Element &#123; var result: Element = 0 for item in self &#123; result += item &#125; return result &#125;&#125;extension Collection where Element: Equatable &#123; func prefieIsEqualSuffix(_ n: Int) -&gt; Bool &#123; let head = prefix(n) let suff = suffix(n).reversed() return head.elementsEqual(suff) &#125;&#125;Keyword：guardDescription： 详见func updateWatchApplicationContext() &#123; let session = WCSession.defaultSession() guard session.watchAppInstalled else &#123; return &#125; do &#123; let context = [\"token\": api.token] try session.updateApplicationContext(context) &#125; catch &#123; print(error) &#125;&#125;Keyword：returnDescription：方法返回值func greet(person: String) -&gt; String &#123; let greeting = \"Hello, \" + person + \"!\" return greeting&#125;Keyword：breakDescription：立刻结束整个控制流的执行。如果是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。import Cocoavar index = 10repeat&#123; index = index + 1 if( index == 15 )&#123; // index 等于 15 时终止循环 break &#125; print( \"index 的值为 \\(index)\")&#125;while index &lt; 20Keyword: continueDescription：一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do…while 循环，continue 语句重新执行条件判断语句。import Cocoa var index = 10repeat&#123; index = index + 1 if( index == 15 )&#123; // index 等于 15 时跳过 continue &#125; print( \"index 的值为 \\(index)\")&#125;while index &lt; 20Keyword：in/// 闭包中&#123; (s:String)-&gt;() in // body&#125;/// for-in 循环import Cocoafor index in 1...5 &#123; print(\"\\(index) 乘于 5 为：\\(index * 5)\")&#125;Keyword: deferDescription: 详见func operateOnFile(descriptor: Int32) &#123; let fileHandle = FileHandle(fileDescriptor: descriptor) defer &#123; fileHandle.closeFile() &#125; let data = fileHandle.readDataToEndOfFile() if /* onlyRead */ &#123; return &#125; let shouldWrite = /* 是否需要写文件 */ guard shouldWrite else &#123; return &#125; fileHandle.seekToEndOfFile() fileHandle.write(someData)&#125;异常处理关键字Keyword：do，try, catch，throw，throws，rethrowsDescription: 参考1，参考2类型相关的关键字Keyword：Any,as，is，nil， super，self， Self, Type/// Any：用于表示任意类型的实例，包括函数类型。var anything = [Any]()anything.append(\"Any Swift type can be added\") anything.append(0) anything.append(&#123;(foo: String) -&gt; String in \"Passed in (foo)\"&#125;)/// as：类型转换运算符，用于尝试将值转成其它类型。let intInstance = anything[1] as? Int/// is：类型检查运算符，用于确定实例是否为某个子类类型。class Person &#123;&#125; class Programmer : Person &#123;&#125; class Nurse : Person &#123;&#125;let people = [Programmer(), Nurse()]for aPerson in people &#123; if aPerson is Programmer &#123; print(\"This person is a dev\") &#125; else if aPerson is Nurse &#123; print(\"This person is a nurse\") &#125; &#125;/// nil：在 Swift 中表示任意类型的无状态值。与 Objective-C 中的 nil 不同，Objective-C 中的 nil 表示指向不存在对象的指针。//任何 Swift 类型或实例可以为 nilvar statelessPerson:Person? = nil var statelessPlace:Place? = nil var statelessInt:Int? = nil var statelessString:String? = nil/// super：在子类中，暴露父类的方法、属性、下标。class Person &#123; func printName() &#123; print(\"Printing a name. \") &#125; &#125;class Programmer : Person &#123; override func printName() &#123; super.printName() print(\"Hello World!\") &#125; &#125;let aDev = Programmer() aDev.printName() //打印 Printing a name. Hello World!/// self：任何类型的实例都拥有的隐式属性，等同于实例本身。此外还可以用于区分函数参数和成员属性名称相同的情况。class Person &#123; func printSelf() &#123; print(\"This is me: (self)\") &#125; &#125;let aPerson = Person() aPerson.printSelf() //打印 \"This is me: Person\"/// Self：在协议中，表示遵守当前协议的实体类型。protocol Printable &#123; func printTypeTwice(otherMe:Self) &#125;struct Foo : Printable &#123; func printTypeTwice(otherMe: Foo) &#123; print(\"I am me plus (otherMe)\") &#125; &#125;let aFoo = Foo() let anotherFoo = Foo()aFoo.printTypeTwice(otherMe: anotherFoo) //打印 I am me plus Foo()/// Type：表示任意类型的类型，包括类类型、结构类型、枚举类型、协议类型。class Person &#123;&#125; class Programmer : Person &#123;&#125;let aDev:Programmer.Type = Programmer.self自定义运算符相关的关键字Keyword：left，right, prefix， postfix，infix，operator，associativity， precedenceDescription： 参考Keyword: noneDescription: 一个没有结合性的运算符。不允许这样的运算符相邻出现。// \"&lt;\" 是非结合性的运算符1 &lt; 2 &lt; 3 //编译失败内存管理相关的关键字Keyword: weak, unowned/// unowned：让循环引用中的实例 A 不要强引用实例 B。前提条件是实例 B 的生命周期要长于 A 实例。class Person &#123; var occupation:Job? &#125;//当 Person 实例不存在时，job 也不会存在。job 的生命周期取决于持有它的 Person。class Job &#123; unowned let employee:Person init(with employee:Person) &#123; self.employee = employee &#125; &#125;/// weak：允许循环引用中的实例 A 弱引用实例 B ，而不是强引用。实例 B 的生命周期更短，并会被先释放。class Person &#123; var residence:House? &#125;class House &#123; weak var occupant:Person? &#125;var me:Person? = Person() var myHome:House? = House()me!.residence = myHome myHome!.occupant = meme = nil myHome!.occupant // myHome 等于 nil以#开头的关键字/// #available：基于平台参数，通过 if，while，guard 语句的条件，在运行时检查 API 的可用性。if #available(iOS 10, *) &#123; print(\"iOS 10 APIs are available\") &#125;/// #colorLiteral：在 playground 中使用的字面表达式，用于创建颜色选取器，选取后赋值给变量。let aColor = #colorLiteral //创建颜色选取器/// #column：一种特殊的字面量表达式，用于获取字面量表示式的起始列数。class Person &#123; func printInfo() &#123; print(\"Some person info - on column (#column)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - on column 53/// #else：条件编译控制语句，用于控制程序在不同条件下执行不同代码。与 #if 语句结合使用。当条件为 true，执行对应代码。当条件为 false，执行另一段代码。#if os(iOS) print(\"Compiled for an iOS device\") #else print(\"Not on an iOS device\") #endif/// #elseif：条件编译控制语句，用于控制程序在不同条件下执行代码。与 #if 语句结合使用。当条件为 true，执行对应代码。#if os(iOS) print(\"Compiled for an iOS device\") #elseif os(macOS) print(\"Compiled on a mac computer\") #endif/// #endif：条件编译控制语句，用于控制程序在不同条件下执行代码。用于表明条件编译代码的结尾。#if os(iOS) print(\"Compiled for an iOS device\") #endif/// #file：特殊字面量表达式，返回当前代码所在源文件的名称。class Person &#123; func printInfo() &#123; print(\"Some person info - inside file (#file)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - inside file /*代码所在 playground 文件路径*//// #fileReference：playground 字面量语法，用于创建文件选取器，选取并返回 NSURL 实例。let fontFilePath = #fileReference //创建文件选取器/// #function：特殊字面量表达式，返回函数名称。在方法中，返回方法名。在属性的 getter 或者 setter 中，返回属性名。在特殊的成员中，比如 init 或 subscript 中，返回关键字名称。在文件的最顶层时，返回当前所在模块名称。class Person &#123; func printInfo() &#123; print(\"Some person info - inside function (#function)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - inside function printInfo()/// #if：条件编译控制语句，用于控制程序在不同条件下编译代码。通过判断条件，决定是否执行代码。#if os(iOS) print(\"Compiled for an iOS device\") #endif/// #imageLiteral：playground 字面量语法，创建图片选取器，选择并返回 UIImage 实例。let anImage = #imageLiteral //在 playground 文件中选取图片/// #line：特殊字面量表达式，用于获取当前代码的行数。class Person &#123; func printInfo() &#123; print(\"Some person info - on line number (#line)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - on line number 5/// #selector：用于创建 Objective-C selector 的表达式，可以静态检查方法是否存在，并暴露给 Objective-C。//静态检查，确保 doAnObjCMethod 方法存在 control.sendAction(#selector(doAnObjCMethod), to: target, forEvent: event)/// #sourceLocation：行控制语句，可以指定与原先完全不同的行数和源文件名。通常在 Swift 诊断、debug 时使用。#sourceLocation(file:\"foo.swift\", line:6)/// 打印新值print(#file) print(#line)// 重置行数和文件名#sourceLocation()print(#file) print(#line)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"}]},{"title":"IjkPlayer 从编译集成到简单音频播放器的封装 [Android & iOS] 一","slug":"audio/ijkplayer_01","date":"2019-11-20T09:33:38.617Z","updated":"2021-06-19T09:10:50.449Z","comments":true,"path":"audio/ijkplayer_01/","link":"","permalink":"http://davidxiaoshuo.github.io/audio/ijkplayer_01/","excerpt":"","text":"编译篇【Android】背景IjkPlayer 是 bilibili 团队出品的一款基于 FFmpeg 的轻量级的音视频播放器。官方地址： ijkplayer由于我所在项目需要一款音频播放器，所以后面都是基于这个大前提来做的。环境准备编译环境：macOS所需要工具：homebrew 【软件包管理器】, git 【分散式版本控制工具】, yasm 【汇编编译器】# 安装 homebrewruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"# 安装 gitbrew install git# 安装 yasmbrew install yasm配置环境变量：# add these lines to your ~/.bash_profile or ~/.profile or ~/.zshrc (取决于你使用的终端工具)export ANDROID_SDK=&lt;your sdk path&gt;export ANDROID_NDK=&lt;your ndk path&gt; 【最好区别于你的开发环境变量配置】Note： 由于 ijkplayer 代码比较古老了，NDK 环境最好选择 14 版本。 NDK 下载链接编译通过 git 将 ijkplayer 源码 clone 到本地git clone https://github.com/bilibili/ijkplayer.git &lt;you local path&gt;下载 FFmpeg./init-android.sh下载 OpenSSL, 增加 https 支持./init-android-openssl.sh编译 OpenSSLcd android/contrib./compile-openssl.sh clean./compile-openssl.sh all编译 FFmpegcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh all编译 ijkplayercd android./compile-ijk.sh clean./compile-ijk.sh allNote: 编译说明：compile-openssl.sh &amp; compile-ffmpeg.sh &amp; compile-ijk.sh 后面的参数代表要变哪个CPU架构的版本，默认是 armv7a；armv5 armv7a arm64 x86 x86_64(指定编译哪个版本)all32（所有32位处理器版本，包含armv5 armv7a x86all （所有通用版本，包含armv5 armv7a arm64 x86 x86_64)clean （清除之前编译的缓存）check (检测支持的版本)编译 FFmpeg 说明编译 ffmpeg 时，根据自己的需求来确定你需要的是更多的 codec/format, 还是轻量级的 codec/format 就可以了。【官方文档有描述。后面将会专门讲配置特定需求的 codec/format】if you prefer more codec/formatcd configrm module.shln -s module-default.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh cleanif you prefer less codec/format for smaller binary size (include hevc function) 【hevc: HEVC是High Efficiency Video Coding的缩写，是一种新的视频压缩标准，用来以替代H.264/AVC编码标准，2013年1月26号，HEVC正式成为国际标准。】cd configrm module.shln -s module-lite-hevc.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh cleanif you prefer less codec/format for smaller binnary size (by default)cd configrm module.shln -s module-lite.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh clean编译中遇到的问题NDK 版本引起的问题，强烈建议选择 r14b 版本，上面有 ndk 下载链接确认你的 NDK 版本是否大于等于 r10ecat $ANDROID_NDK/source.propertiesPkg.Desc = Android NDKPkg.Revision = 14.1.3816874 // 我的NDK版本确定了你的 NDK 版本符合要求，还是报了如下错误You need the NDKr10e or later那么你就要需要修改如下代码, 把你的版本添加进版本检查中：cd android/contrib/toolvim do-detect-env.shIJK_NDK_REL=$(grep -o '^Pkg\\.Revision.*=[0-9]*.*' $ANDROID_NDK/source.properties 2&gt;/dev/null | sed 's/[[:space:]]*//g' | cut -d \"=\" -f 2)echo \"IJK_NDK_REL=$IJK_NDK_REL\"case \"$IJK_NDK_REL\" in 11*|12*|13*|14*|15*|20*) if test -d $&#123;ANDROID_NDK&#125;/toolchains/arm-linux-androideabi-4.9 then echo \"NDKr$IJK_NDK_REL detected\" else echo \"You need the NDKr10e or later\" exit 1 fi ;; *) echo \"You need the NDKr10e or later\" exit 1 ;;由于 ndk 兼容问题导致 standalone toolchain， 如果 macOS 遇到这个问题，可以将使用 r14b 版本的 NDK； 参考链接====================[*] check archs====================FF_ALL_ARCHS = armv5 armv7a arm64 x86 x86_64FF_ACT_ARCHS = armv5 armv7a arm64 x86 x86_64--------------------[*] make NDK standalone toolchain--------------------build on Darwin x86_64ANDROID_NDK=/Users/davidxiaoshuo/Documents/dev_tools/android/sdk/ndk-bundleIJK_NDK_REL=20.0.5594570NDKr20.0.5594570 detected--------------------[*] make NDK standalone toolchain--------------------build on Darwin x86_64ANDROID_NDK=/Users/davidxiaoshuo/Documents/dev_tools/android/sdk/ndk-bundleIJK_NDK_REL=20.0.5594570NDKr20.0.5594570 detectedHOST_OS=darwinHOST_EXE=HOST_ARCH=x86_64HOST_TAG=darwin-x86_64HOST_NUM_CPUS=12BUILD_NUM_CPUS=24Auto-config: --arch=armERROR: Failed to create toolchain.其他方面导致的问题编译模型脚本 （module.sh）导致的问题WARNING: arm-linux-androideabi-pkg-config not found, library detection may fail.--------------------[*] compile ffmpeg--------------------In file included from ./libavutil/internal.h:42:0, from ./libavutil/common.h:467, from ./libavutil/avutil.h:296, from ./libavutil/opt.h:31, from libavfilter/af_adelay.c:22:./libavutil/timer.h:38:31: fatal error: linux/perf_event.h: No such file or directory # include &lt;linux/perf_event.h&gt; ^compilation terminated.In file included from ./libavutil/internal.h:42:0, from ./libavutil/common.h:467, from ./libavutil/avutil.h:296, from libavfilter/avfilter.h:41, from libavfilter/audio.h:25, from libavfilter/af_acopy.c:19:./libavutil/timer.h:38:31: fatal error: linux/perf_event.h: No such file or directory # include &lt;linux/perf_event.h&gt;可以在 module.sh 最后添加 export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot; 这行代码。 参考链接","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"audio","slug":"audio","permalink":"http://davidxiaoshuo.github.io/tags/audio/"}]},{"title":"Android Jni 一","slug":"android/android_jni_one","date":"2019-08-26T13:25:35.835Z","updated":"2021-06-19T09:10:51.472Z","comments":true,"path":"android/android_jni_one/","link":"","permalink":"http://davidxiaoshuo.github.io/android/android_jni_one/","excerpt":"","text":"通过 Android Studio 创建一个 Native C++ 的工程本文中选用 C++11 进行开发","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"Android Studio Gradle's Logger","slug":"android/android_gradle_logger","date":"2019-08-23T01:21:06.375Z","updated":"2021-06-19T09:10:12.523Z","comments":true,"path":"android/android_gradle_logger/","link":"","permalink":"http://davidxiaoshuo.github.io/android/android_gradle_logger/","excerpt":"","text":"前言: 我们在通过 Android Studio 进行 android 开发的时候，难免需要在进行 Gradle 编译构建的时候需要输出一些信息来辅助我们进行配置调试，或是需要输出一些必要信息来提醒其他开发者，此时，我们就要了解下 gradle 的 log 打印相关辅助工具类了。补充：Gradle -&gt; 构建系统工具，它的 DSL 基于 Groovy 实现日志级别级别用途ERROR错误信息QUIET重要信息WARNING警告信息LIFECYCLE进度信息INFO内容信息DEBUG调试信息package org.gradle.api.logging;/** * The log levels supported by Gradle. */public enum LogLevel &#123; DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR&#125;日志开关选项开关选项输出的日志级别无选项LIFECYCLE及更高级别-q 或 --quietQUIRT及更高级别-i 或 --infoINFO及更高级别-d 或 --debugDEBUG及更高级别(全部日志)// 输出 INFO及更高级别的日志gradle -i task提醒： Android Studio 默认情况开启的是LIFECYCLE及更高级别, 所以此时在通过 Android Studio 进行默认 Build 操作时，此时在 Build Output 控制台打印出来的是这个级别的，Info，Debug Log 并不会输出在 gradle 中尝试打印Loglogger.error('this is log of gradle, level ---&gt; error')logger.quiet('this is log of gradle, level ---&gt; quiet')logger.warn('this is log of gradle, level ---&gt; warn')logger.lifecycle('this is log of gradle, level ---&gt; lifecycle')logger.info('this is log of gradle, level ---&gt; info')logger.debug('this is log of gradle, level ---&gt; debug')在验证时，通过 -d 得到以下输出，验证 Log 级别10:01:42.029 [ERROR] [org.gradle.api.Project] this is log of gradle, level ---&gt; error10:01:42.029 [QUIET] [org.gradle.api.Project] this is log of gradle, level ---&gt; quiet10:01:42.029 [WARN] [org.gradle.api.Project] this is log of gradle, level ---&gt; warn10:01:42.029 [LIFECYCLE] [org.gradle.api.Project] this is log of gradle, level ---&gt; lifecycle10:01:42.029 [INFO] [org.gradle.api.Project] this is log of gradle, level ---&gt; info10:01:42.029 [DEBUG] [org.gradle.api.Project] this is log of gradle, level ---&gt; debugprintf 在 gradle 中也是可以再 Build Output 控制台中输出 Log 的10:07:24.545 [QUIET] [system.out] this is log of gradle, event ---&gt; printf","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"}]},{"title":"Android JNI 层 Log 输出","slug":"android/jni_logger","date":"2019-08-11T13:46:12.315Z","updated":"2021-06-19T09:10:24.542Z","comments":true,"path":"android/jni_logger/","link":"","permalink":"http://davidxiaoshuo.github.io/android/jni_logger/","excerpt":"","text":"概述：android 中在进行一些 C++ 底层库开发的时候难免需要一些 log 来辅助我们的开发调试，或是打印一些重要信息给到 Lib 库的使用者。在 android 中，通过 C++ 层的 print Or std::cout 是无法在logcat 中正常显示 log 信息的。android NDK 专门提供了相关的 Logging 工具。__android_log_print 主要使用的函数int __android_log_print( int prio, //优先级 const char *tag, //标签 const char *fmt, // format log string ...)cmake 编译， 在 CMakeLists.txt 中配置需要依赖的 Log 系统库#查找要依赖的系统库find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )#指定要生成的动态库所依赖的库（系统库，外部第三方库）target_link_libraries( # Specifies the target library. # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; )通过对 __android_log_print 稍加修改，来使 log 输出变得更加简单首先要引入所需的头文件 #include &lt;android/log.h&gt;#include &lt;android/log.h&gt;#define TAG \"ProjectName\" // 这个是自定义的LOG的标识 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型，在 Release 模式下禁用 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型 #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型 #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型使用char* log_example_str = \"hello logger\";LOGD(\"This is a log, the content is %s\", log_example_str);LOGI(\"This is a log, the content is %s\", log_example_str);LOGW(\"This is a log, the content is %s\", log_example_str);LOGE(\"This is a log, the content is %s\", log_example_str);LOGF(\"This is a log, the content is %s\", log_example_str);","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"","slug":"menu","date":"2019-08-09T11:17:00.068Z","updated":"2021-06-18T11:33:25.096Z","comments":true,"path":"menu/","link":"","permalink":"http://davidxiaoshuo.github.io/menu/","excerpt":"","text":"Techandroidandroid studio cmake 编译常规设置Android Jni 层 Log 输出c++C++ 中 基础类型转换成 char*macos 远程硬盘挂载USB 转串口工具 minicom SetupgitGit 多github（gitlab）账号管理othersHexo Page 简单发布流程MacOS Terminal 美化 【程序猿推荐】Life","categories":[],"tags":[]},{"title":"USB 转串口工具 minicom Setup","slug":"others/minicom_setup","date":"2019-08-05T06:11:26.384Z","updated":"2021-06-19T09:09:23.762Z","comments":true,"path":"others/minicom_setup/","link":"","permalink":"http://davidxiaoshuo.github.io/others/minicom_setup/","excerpt":"","text":"准备工作安装 minicom 串口调试工具, 通过 Homebrew 安装即可brew install minicomSetup将串口线连接到电脑USB上，查看当前命令行查看连接的串口号ls /dev/tty*上图中的 /dev/tty.usbserial-14340 就是 USB 的串口号将串口号配置给串口工具 minicom命令打开串口工具minicom -s通过键盘上的 J, K 或者方向键上下移动到 Serial port setup 选项，按回车选中，进入串口设置界面通过键盘上的大写字母 A 选中进入 Serial Device 选项，并将之前复制好的串口号粘贴在此，并按两次回车, 回到主 Setup 界面。定位到 Save setup as dfl 回车并选中。定位到 Exit 退出 Setup 界面到 串口命令终端中 或 定位到 Exit from minicom 退回到系统命令界面","categories":[{"name":"DevEnv","slug":"DevEnv","permalink":"http://davidxiaoshuo.github.io/categories/DevEnv/"}],"tags":[{"name":"env","slug":"env","permalink":"http://davidxiaoshuo.github.io/tags/env/"}]},{"title":"macos 远程硬盘挂载","slug":"others/macos_remote_disk_mount","date":"2019-08-05T06:08:40.805Z","updated":"2021-06-19T09:09:18.210Z","comments":true,"path":"others/macos_remote_disk_mount/","link":"","permalink":"http://davidxiaoshuo.github.io/others/macos_remote_disk_mount/","excerpt":"","text":"准备工作安装Homebrew, 具体安装方式，见官网通过Homebrew 安装 sshfs 的依赖 fusebrew install Caskroom/cask/osxfuse通过Homebrew 安装sshfsbrew install sshfs使用sshfs remote_account@ip:remote_directory /local/directory挂载到本地时，避免挂在到根目录下或者当前账户的主目录下，否则会引起以下错误：mount_osxfuse: mount point /Users/xxxx/ImageFolder is itself on a OSXFUSE volumefuse: failed to mount file system: Invalid argument","categories":[{"name":"DevEnv","slug":"DevEnv","permalink":"http://davidxiaoshuo.github.io/categories/DevEnv/"}],"tags":[{"name":"env","slug":"env","permalink":"http://davidxiaoshuo.github.io/tags/env/"}]},{"title":"Home Page","slug":"home","date":"2019-08-04T14:55:28.419Z","updated":"2021-06-19T08:48:20.937Z","comments":true,"path":"home/","link":"","permalink":"http://davidxiaoshuo.github.io/home/","excerpt":"","text":"Home PageHi, 这里是我记录我所感兴趣的技术，生活的地方。如果技术上有错误的地方欢迎联系我，并指正。昵称：David小硕职业：移动端技术研发经理主攻技术方向：Android; iOS; C++公司：北京物灵科技有限公司","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]},{"title":"C++ 中 基础类型转换成 char *","slug":"c++/cplus_type_convert","date":"2019-08-04T05:33:15.437Z","updated":"2021-06-19T09:12:46.881Z","comments":true,"path":"c++/cplus_type_convert/","link":"","permalink":"http://davidxiaoshuo.github.io/c++/cplus_type_convert/","excerpt":"","text":"C++ 中 基础类型转换成 char*有时候我们在项目中难免会用到，将基础数据类型转换成char*，这样会方面一些业务上的开展。前一阵子做基于mips 平台下 阿里云Log Service时候就用到了，由于考虑要封装sdk的轻量性，所以没有考虑依赖其他的系统库。以下demo 代码依赖如下系统库，#include &lt;stdio.h&gt;#include &lt;string&gt;基础数据类型的相互转换其实有多种方式。以下多是通过 printf 方式来完成的。int 转 char *char* int_to_char_ptr(int src) &#123; char result[30] = \"\"; sprintf(result, \"%d\", src); char* ret_value = result; return ret_value;&#125;double 转 char*char* double_to_char_ptr(double src) &#123; char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xlf sprintf(result, \"%lf\", src); char* ret_value = result; return ret_value;&#125;float 转 char*char* float_to_char_ptr(float src) &#123; char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xf sprintf(result, \"%f\", src); char* ret_value = result; return ret_value;&#125;size_t 转 char*char* size_t_to_char_ptr(size_t value) &#123; char result[30] = \"\"; sprintf(result, \"%zu\", value); char * ret_value = result; return ret_value;&#125;string 转 char*char* str_to_char_array(std::string value) &#123; return const_cast&lt;char*&gt;(value.c_str());&#125;char* 转 stringstd::string char_ptr_to_str(const char* value) &#123; std::string res; res = value; return res;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://davidxiaoshuo.github.io/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://davidxiaoshuo.github.io/tags/c/"}]},{"title":"MacOS Terminal 美化 【程序猿推荐】","slug":"others/macos_terminal_themes","date":"2019-05-11T07:51:02.823Z","updated":"2021-06-19T09:09:07.802Z","comments":true,"path":"others/macos_terminal_themes/","link":"","permalink":"http://davidxiaoshuo.github.io/others/macos_terminal_themes/","excerpt":"","text":"MacOS Terminal 美化 【程序猿推荐】工欲善其事，必先利其器我们在MacOS 下开发的时候不可避免一定为会用的terminal，不管你是server端选手，客户端选手，又或者是…哎呀，等等吧，总之terminal是我们在开发中使用评率比较高的基础开发工具了。但是原生的terminal，是一个及其简陋的家伙。那么怎么能让我们的terminal能够看起来既舒服又能超好用呢。动起手来…先晒一张我的terminal截图：改造Terminal步骤安装oh-my-zsh设置 oh-my-zsh 主题安装 oh-my-zsh 日常所需的插件，以提高工作效率修改 Terminal 的Profile，让我们的 Terminal 与 zsh 的主题更加匹配准备工作(可能会需要)首先我们先安装MacOS 中比较好用的软件包管理器 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"安装 oh-my-zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"配置 oh-my-zsh 主题首先我们链接到 oh-my-zsh 主题的页面 --&gt; https://github.com/robbyrussell/oh-my-zsh/wiki/Themes选择我们喜欢的主题，然后记住主题名字，这里我的主题名字是：pygmalion然后我们打开Terminal窗口输入以下命令对 .zshrc 文件进行编辑vim ~/.zshrc// 将 ZSH_THEME 设置为即将要是用的主题名称ZSH_THEME=\"pygmalion\"设置成功后，退出vim。执行以下命令，使刚刚的设置生效：source ~/.zshrc如果你细心你会发现实际上oh-my-zsh在安装的时候已经内置了很多的主题。cd ~/.oh-my-zsh/themes // 主题目录cd ~/.oh-my-zsh/plugins // 插件所在目录安装oh-my-zsh插件oh-my-zsh 的插件有很多，它本身内置的插件也有很多，但是我们在用的时候可以根据需要设置需要的即可。因为插件安装过多，一定程度上会使zsh的命令执行效率变低zsh-syntax-highlightingzsh 语法高亮插件，官方地址vim ~/.zshrc//添加如下脚本plugins=( git zsh-syntax-highlighting)安装效果如下：修改 Terminal 的Profile，导入我们想要的主题 【我选择的是Fideloper】macos-terminal-themes 提供了丰富的主题供我们选择，我们可以在当中找一款与我们所选zsh主题相符合的主题。将 macos-terminal-themes 下载到本地进入到 schemes 目录下双击 *.terminal 的文件，将会打开一个所选主题的新的Terminal窗口选择Terminal 工具栏中的 Shell -&gt; Use Setting as Default, 即将主题修改为所选主题。","categories":[{"name":"Other","slug":"Other","permalink":"http://davidxiaoshuo.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://davidxiaoshuo.github.io/tags/other/"}]},{"title":"android studio cmake 编译常规设置","slug":"android/cmake_list","date":"2019-04-24T04:01:45.000Z","updated":"2021-06-19T09:10:53.032Z","comments":true,"path":"android/cmake_list/","link":"","permalink":"http://davidxiaoshuo.github.io/android/cmake_list/","excerpt":"","text":"add_executable 指令语法：add_executable(executable_file_name [source])将一组源文件 source 生成一个可执行文件。 source 可以是多个源文件，也可以是对应定义的变量 如：add_executable(hello main.c)cmake_minimun_required(VERSION 3.4.1)用来指定 CMake 最低版本为3.4.1，如果没指定，执行 cmake 命令时可能会出错add_subdirectory 指令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数含义是将这个目录从编译过程中排除。另外，也可以通过 SET 指令重新定义EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置 (指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件)set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)add_library 指令语法：add_library(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])将一组源文件 source 编译出一个库文件，并保存为 libname.so (lib 前缀是生成文件时 CMake自动添加上去的)。其中有三种库文件类型，不写的话，默认为 STATIC:SHARED: 表示动态库，可以在(Java)代码中使用System.loadLibrary(name)动态调用；STATIC: 表示静态库，集成到代码中会在编译时调用；MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待；EXCLUDE_FROM_ALL: 表示这个库不被默认构建，除非其他组件依赖或手工构建#将compress.c 编译成 libcompress.so 的共享库add_library(compress SHARED compress.c)add_library 命令也可以用来导入第三方的库:add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED) 如，导入 libjpeg.soadd_library(libjpeg SHARED IMPORTED)导入库后，当需要使用 target_link_libraries 链接库时，可以直接使用该库find_library 指令语法：find_library(name1 path1 path2 …)VAR 变量表示找到的库全路径，包含库文件名 。例如：find_library(libX X11 /usr/lib)find_library(log-lib log)#路径为空，应该是查找系统环境变量路径set_target_properties 指令语法:set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），对于动态库，还可以用来指定动态库版本和 API 版本。如: set_target_properties(hello_static PROPERTIES OUTPUT_NAME “hello”) 设置同名的 hello 动态库和静态库：set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)set_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)指定要导入的库文件的路径add_library(jpeg SHARED IMPORTED)#注意要先 add_library，再 set_target_propertiesset_target_properties(jpeg PROPERTIES IMPORTED_LOCATION $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libjpeg.so)设置动态库 hello 版本和 API 版本：set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)和它对应的指令：get\\_target_property(VAR target property)。如上面的例子，获取输出的库的名字get_target_property(OUTPUT_VALUE hello_static OUTPUT_NAME)message(STATUS \"this is the hello_static OUTPUT_NAME:\"$&#123;OUTPUT_VALUE&#125;)include_directories 指令语法：include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)这个指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。target_link_libraries 指令语法：target_link_libraries(target library library2…)这个指令可以用来为 target 添加需要的链接的共享库，同样也可以用于为自己编写的共享库添加共享库链接。如：#指定 compress 工程需要用到 libjpeg 库和 log 库target_link_libraries(compress libjpeg $&#123;log-lib&#125;)同样，link_directories(directory1 directory2 …) 可以添加非标准的共享库搜索路径。还有其他 file、list、install 、find_ 指令和控制指令等就不介绍了，详细可以查看手册。CMake 的常用变量变量引用方式使用 ${} 进行变量的引用。不过在 IF 等语句中，可以直接使用变量名而不用通过 ${} 取值自定义变量的方式主要有隐式定义和显式定义两种。隐式定义，如 PROJECT 指令会隐式定义_BINARY_DIR 和_SOURCE_DIR而对于显式定义就是通过 SET 指令来定义。如：set(HELLO_SRC main.c)CMake 常用变量CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, _BINARY_DIR这三个变量指代的内容都是一样的，如果是 in-source 编译，指的是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, _SOURCE_DIR这三个变量指代的内容也是一样的，不论哪种编译方式，都是工程顶层目录。CMAKE_CURRENT_SOURCE_DIR当前处理的 CMakeLists.txt 所在的路径CMAKE_CURRENT_BINARY_DIR如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致，如果是 out-of-source 编译，指的是 target 编译目录。使用 ADD_SUBDIRECTORY(src bin)可以修改这个变量的值；而使用 SET(EXECUTABLE_OUTPUT_PATH &amp;lt; 新路径&amp;gt;) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行CMAKE_MODULE_PATH 这个变量用来定义自己的 CMake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。比如：SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。PROJECT_NAME返回通过 PROJECT 指令定义的项目名称。Android CMake 的使用CMakeList.txt 的编写再回归到 Android NDK 开发中 CMake 的使用，先看一个系统生成的 NDK 项目的 CMakeLists.txt 的配置：(去掉原有的注释)# 设置编译 native library 需要最小的 cmake 版本cmake_minimum_required(VERSION 3.4.1)# 将指定的源文件编译为名为 libnative-lib.so 的动态库add_library(native-lib SHARED src/main/cpp/native-lib.cpp)# 查找本地 log 库find_library(log-lib log)# 将预构建的库添加到自己的原生库target_link_libraries(native-lib $&#123;log-lib&#125;)复杂一点的 CMakeLists，这是一个本地使用 libjpeg.so 来做图片压缩的项目cmake_minimum_required(VERSION 3.4.1)#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;)#指定要引用的libjpeg.so的头文件目录set(LIBJPEG_INCLUDE_DIR src/main/cpp/include)include_directories($&#123;LIBJPEG_INCLUDE_DIR&#125;)#导入libjpeg动态库 SHARED；静态库为STATICadd_library(jpeg SHARED IMPORTED)#对应so目录，注意要先 add_library，再 set_target_properties）set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libjpeg.so)add_library(compress SHARED src/main/cpp/compress.c)find_library(graphics jnigraphics)find_library(log-lib log)#添加链接上面个所 find 和 add 的 librarytarget_link_libraries(compress jpeg $&#123;log-lib&#125; $&#123;graphics&#125;)配置 Gradle简单的配置如下，至于 cppFlags 或 cFlags 的参数有点复杂，一般设置为空或不设置也是可以的，这里就不过多介绍了android &#123;compileSdkVersion 25buildToolsVersion \"25.0.3\"defaultConfig &#123; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName \"1.0\" externalNativeBuild &#123; cmake &#123; // Passes optional arguments to CMake. arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\" // Sets optional flags for the C compiler. cFlags \"-D_EXAMPLE_C_FLAG1\",\"-D_EXAMPLE_C_FLAG2\" // Sets a flag to enable format macro constants for the C++ compiler. cppFlags \"-D__STDC_FORMAT_MACROS\" //生成.so库的目标平台 abiFilters 'x86','x86_64','armeabi','armeabi-v7a','arm64-v8a' &#125; &#125;&#125;//配置 CMakeLists.txt 路径externalNativeBuild &#123; cmake &#123; path \"CMakeLists.txt\" &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"Git 多github（gitlab）账号管理","slug":"git/git_multi_account_manager","date":"2019-04-23T08:31:52.000Z","updated":"2021-06-19T09:12:00.558Z","comments":true,"path":"git/git_multi_account_manager/","link":"","permalink":"http://davidxiaoshuo.github.io/git/git_multi_account_manager/","excerpt":"","text":"场景：很多时候我们有公司的github的账号同时自己私下还可能会有多个git平台的账号（如：github，gitlab）。这时候在管理git账号，指定哪个项目用哪个账号，放在哪个账户的仓库下，就显得尤为重要了。下面简单说下如何配置git config 文件去管理这些git平台账号。1. 生成ssh-key$ ssh-keygen -t rsa -C \"youremail@company.com” -f ~/.ssh/id-rsaexplain：这样在~/.ssh/目录下就会生成id-rsa和id-rsa.pub的公钥和私钥。其中id-rsa 我们可以根据我们自己的需求来定义名称，例如我的名称personal-github-id-rsa(私人），company-github-id-rsa（公司github），company-gitlab-id-rsa（公司gitlab）。生成ssh-key 后我们可以copy 公钥到各git平台$ pbcopy &lt; ~/.ssh/id-rsa通过上面的命令将公钥copy到剪贴板，然后到git平台的ssh-key页面直接粘贴即可。2. 添加私钥$ ssh-add ~/.ssh/id-rsa将私钥添加到我们本地ssh中# 可以通过 ssh-add -l 来确私钥列表$ ssh-add -l# 可以通过 ssh-add -D 来清空私钥列表$ ssh-add -D3. 创建多账号管理文件touch ~/.ssh/configvim config# gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-gitlab-id-rsa# githubHost github-company HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-github-id-rsa#personal-githubHost github-personal HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/personal-github-rsaexplain: Host 这里可以理解为我们为实际的host（如：github.com）起的别名，HostName才是实际的host address值，这样我们在本地仓库指定远程仓库的时候就可以区分出同一个平台下的不同账号体系了，可以通过下面的remote repository 地址可以看出。4. 为本地仓库指定远程仓库地址4.1 远程仓库地址，从github中直接复制显示：4.2 实际为本地仓库指定远程仓库地址需要这样：添加地址：git remote add origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git重定向地址：git remote set-url origin git@github-personal:Davidxiaoshuo/EmotionCalendar.gitexplain: 其中git@后面的字段为我们在config配置文件中的Host的值","categories":[{"name":"Git","slug":"Git","permalink":"http://davidxiaoshuo.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://davidxiaoshuo.github.io/tags/git/"}]},{"title":"Hello World","slug":"others/hello_world","date":"2019-04-19T07:39:43.000Z","updated":"2021-06-19T09:09:00.111Z","comments":true,"path":"others/hello_world/","link":"","permalink":"http://davidxiaoshuo.github.io/others/hello_world/","excerpt":"","text":"Hexo Page 简单发布流程Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post$ hexo new \"My New Post\"More info: WritingRun server$ hexo serverMore info: ServerGenerate static files$ hexo generateMore info: GeneratingDeploy to remote sites$ hexo deployMore info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"http://davidxiaoshuo.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://davidxiaoshuo.github.io/tags/other/"}]}]}
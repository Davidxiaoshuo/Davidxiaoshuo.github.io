{"meta":{"title":"David硕","subtitle":"write readable code","description":"在这个薄情的世界，深情地活着","author":"David硕","url":"http://davidxiaoshuo.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-14T08:13:41.882Z","updated":"2019-08-14T08:13:41.882Z","comments":false,"path":"/404.html","permalink":"http://davidxiaoshuo.github.io//404.html","excerpt":"","text":""},{"title":"tag","date":"2021-06-19T08:45:43.000Z","updated":"2021-06-19T09:01:14.881Z","comments":true,"path":"tag/index.html","permalink":"http://davidxiaoshuo.github.io/tag/index.html","excerpt":"","text":""},{"title":"category","date":"2021-06-19T08:46:45.000Z","updated":"2021-06-19T09:01:01.815Z","comments":true,"path":"category/index.html","permalink":"http://davidxiaoshuo.github.io/category/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-14T07:53:34.576Z","updated":"2019-08-14T07:53:34.576Z","comments":false,"path":"about/index.html","permalink":"http://davidxiaoshuo.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"Swift 总结之属性重写 「override」","slug":"iOS/swift_override_property","date":"2021-06-18T09:39:07.176Z","updated":"2021-06-19T09:08:06.094Z","comments":true,"path":"iOS/swift_override_property/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_override_property/","excerpt":"","text":"import Cocoaclass Student &#123; // 存储属性 var age: Int = 0 var chineseScore: Double = 0.0 var englishScore: Double = 0.0 // 计算属性 var averageScore: Double &#123; // 访问（获取）调用get get&#123; return (chineseScore + englishScore) / 2 &#125; // 设置值的时候 set&#123; print(\"set\\(newValue)\") // 千万不要在这里设置值 会死循环 外部参数起名字 newvalue // self.averageScore = newValue &#125; &#125; // 只读计算属性 var averageScore2: Double &#123; return (chineseScore + englishScore) / 2 &#125; // 类属性, 不能被重写 static var couseCount = 3 // 懒加载属性 lazy var courses: [String] = &#123; ()-&gt;[String] in print(\"懒加载属性\") return [\"java\", \"html\", \"swift\"] &#125;() // 属性观察器-有的属性很重要，我希望关注每一次赋值的变化。 // 验证 willSet 和 didSet 作用 // 内置变量：newValue oldValue var name: String = \"tt\" &#123; // newValue willSet&#123; print(\"父类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"父类 didSet 被调用, oldValue\\(oldValue)\") &#125; &#125; &#125;// 属性的继承与重写class SeniorStudent : Student&#123; private var _chineseScore: Double = 0.0 // 子类都可以通过提供getter和setter对属性进行重写 // 重写后，存储属性变为计算属性 override var chineseScore: Double&#123; get &#123; return _chineseScore &#125; set &#123; _chineseScore = newValue &#125; &#125; // 不可以将继承来的读写属性重写为只读属性 override var averageScore: Double&#123; get &#123; return 90.5 &#125; set&#123; &#125; &#125; // 如果父类已经添加了属性观察器，当属性发生变化时，父类与子类都会得到通知 override var name:String &#123; // newValue willSet&#123; print(\"子类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"子类 didSet 被调用,oldValue\\(oldValue)\") &#125; &#125; /// 懒加载属性，重写后变为计算属性 override var courses: [String] &#123; get &#123; return [\"swift\", \"OC\"] &#125; set &#123; &#125; &#125; override var averageScore2: Double &#123; return 96.1 &#125;&#125;let student = SeniorStudent()student.chineseScore = 91print(student.chineseScore)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"}]},{"title":"Swift 总结之关键字","slug":"iOS/swift_keyword_summery","date":"2021-06-16T08:31:25.746Z","updated":"2021-06-19T09:07:52.665Z","comments":true,"path":"iOS/swift_keyword_summery/","link":"","permalink":"http://davidxiaoshuo.github.io/iOS/swift_keyword_summery/","excerpt":"","text":"声明式关键字Keyword： classDescription： Swift 语言中一种构造体，它具有以下特性：一个类允许另一个类进行继承，形成父子关系。支持类型转换「type-casting」，允许在运行时，检查 &amp; 指定一个类的实际类型。支持实现协议「protocol」。支持 deinit 析构函数，并且在可以释放所有资源。支持引用计数，允许多个引用指向同一个实例。不支持默认成员初始化构造器「memberwise initializer」。属于引用类型，存储在堆内存中Keyword： structDescription：与 class 一样，也是 Swift 语言中一个重要的构造体，它具有以下特性：支持实现协议支持默认成员初始化构造器「memberwise initializer」。不支持类型转换「type-casting」不支持 deinit析构函数内部方法修改属性时，需要在方法上添加 mutating 关键字属于值类型，存储在栈内存中Keyword：enumDescription：Swift 中的一种数据类型，它是一组有共同特性的数据的集合。它具有以下特性：支持实现协议支持初始化方法「构造方法」内部方法修改属性时，需要在方法上添加 mutating 关键字enum Barcode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125;Keyword：protocolDescription：协议定义了适合特定任务或功能的方法、属性。然后，类、结构或枚举可以采用该协议，以提供这些要求的实际实现。任何满足协议要求的类型都被称为符合该协议。除了指定符合类型必须实现的要求之外，您还可以扩展协议以实现其中一些要求或实现符合类型可以利用的附加功能。详见protocol SomeProtocol &#123; // protocol definition goes here&#125;Keyword： extensionDescription：向现有类、结构、枚举或协议类型添加新功能。这包括扩展您无法访问原始源代码的类型的能力（称为追溯建模）。扩展类似于 Objective-C 中的类别。 （与 Objective-C 类别不同，Swift 扩展没有名称。）详见在 swift 中 extension 有以下具体能力：添加计算实例属性或计算类型属性定义实例方法和类型方法提供新的构造函数定义下标定义和使用新的嵌套类型实现现有需要实现的协议Keyword：initDescription: class, struct, enum 的构造方法。enum Gender: RawRepresentable &#123; typealias RawValue = String case male case female var rawValue: String &#123; switch self &#123; case .male: return \"male\" case .female: return \"female\" &#125; &#125; init?(rawValue: String) &#123; switch rawValue &#123; case \"male\": self = .male case \"female\": self = .female default: return nil &#125; &#125;&#125;struct ClassInfo &#123; var grade: Int var classNum: Int&#125;class Student &#123; var name: String var gender: Gender var classInfo: ClassInfo init(name: String, gender: Gender, classInfo: ClassInfo) &#123; self.name = name self.gender = gender self.classInfo = classInfo &#125;&#125;Keyword： deinitDescription：class 的析构函数，每个类只允许有一个析构函数。析构函数在类实例释放前自动调用，不允许手动调用。超类的析构器由子类继承，在子类析构函数调用结束时，自动调用父类析构函数。 父类的析构器总会被调用，即使子类没有实现析构函数。实际开发中，我们可以通过 deinit 来观察类实例是否被释放。deinit &#123; // perform the deinitialization&#125;Keyword：convenienceDescription: convenience init 是类中次要的，辅助型的构造器，可以调用便利构造来调用同一个类中的指定的构造器，并且为其提供默认值，class Person: NSObject &#123; var age: Int var name: String init(age:Int, name: String) &#123; self.age = age; self.name = name; &#125; convenience init(age: Int, firstName: String, lastName: String) &#123; self.init(age:age, name:firstName+lastName); &#125; convenience init(age: Int, firstName: String, lastName: String, height: CGFloat) &#123; self.init(age: age, firstName: firstName, lastName: lastName); &#125;&#125;class Father: Person &#123; var address: String init(age: Int, name: String, address: String) &#123; self.address = address; super.init(age: age, name: name); &#125; convenience init(age: Int, firstName: String, lastName: String, address: String) &#123; self.init(age: age,name: firstName + lastName, address: address); &#125;&#125;Keyword：requiredDescription: 在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器class SomeClass &#123; var str: String required init(str: String) &#123; self.str = str &#125;&#125;class SomeSubclass: SomeClass &#123; required init(str: String) &#123; super.init(str: str) &#125; init(i: Int) &#123; super.init(str: String(i)) &#125;&#125;var SomeSubclass(str:\"Hello Swift\")Keyword：importDescription: 包导入。 详见import &lt;#module#&gt;import &lt;#kind#&gt; &lt;#module.symbol#&gt;import &lt;#module.submodule#&gt;Keyword： typealiasDescription：typealias 是特定类型的别名。换句话说，类型别名是在你的代码库里插入现有类型的另一个名称。详见typealias Money = IntKeyword: associatedtypeDescription: 关联类型定义。在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。详见Keyword：letDescription：定义一个常量。let constantString = \"hello world!\"Keyword：varDescription: 定义一个变量。var variableString = \"hello my world!\"variableString = \"hello your world!\"Keyword： funcDescription：方法定义。详见func greet(person: String) -&gt; String &#123; let greeting = \"Hello, \" + person + \"!\" return greeting&#125;Keyword：inoutDescription: inout是按值传递，然后再写回原变量，而不是按引用传递。func inc(inout i: Int) &#123; ++i&#125;var x = 0inc(&amp;x)print(x) // 输出结果：“1”func inc(inout i: Int) -&gt; () -&gt; Int &#123; return &#123; ++i &#125; // 闭包中截获inout参数i&#125;var x = 0let f = inc(&amp;x)print(f()) // 输出结果：“1”print(x) // 输出结果：“0”。Keyword：overrideDescription: 属性、方法重写需要用 override修饰。 属性重写参考Keyword: finalDescription：可以在class、func和var前修饰。class Parent &#123; final func method1() &#123; //权限验证（必须执行） //..... method2() //下面是日志记录（必须执行） //.......... &#125; func method2()&#123; //父类的实现 //...... &#125;&#125;class Child : Parent &#123; //只能重写父类的method2方法，不能重写method1方法 override func method2() &#123; //子类的实现 //...... &#125;&#125;Keyword: mutatingDescription: 见Keyword：nonmutatingprotocol Settings &#123; subscript(key: String) -&gt; AnyObject? &#123; get nonmutating set &#125;&#125;struct Test2 &#123; var b: Int &#123; get &#123; return 2 &#125; nonmutating set &#123; print(\"\\(newValue)\") &#125; &#125;&#125;/// 由于这里 t 是常量，如果 setter 中不是使用 nonmutating，编译器会报错/// Cannot assign to property: 't' is a 'let' constantlet t = Test2()t.b = 3print(t.b)Keyword： dynamicDescription: 指明编译器不会对类成员或者函数的方法进行内联或虚拟化。这意味着对这个成员的访问是使用 Objective-C 运行时进行动态派发的（代替静态调用）。 参考1，参考2class Person &#123; //隐式指明含有 \"objc\" 属性 //这对依赖于 Objc-C 黑魔法的库或者框架非常有用 //比如 KVO、KVC、Swizzling dynamic var name:String? &#125;属性声明相关的关键字Keyword： lazy，set， get, willSet, didSet// 懒加载属性lazy var courses: [String] = &#123; ()-&gt;[String] in print(\"懒加载属性\") return [\"java\", \"html\", \"swift\"]&#125;()// 计算属性var averageScore: Double &#123; // 访问（获取）调用get get&#123; return (chineseScore + englishScore) / 2 &#125; // 设置值的时候 set&#123; print(\"set\\(newValue)\") // 千万不要在这里设置值 会死循环 外部参数起名字 newvalue // self.averageScore = newValue &#125;&#125;// 属性观察器-有的属性很重要，我希望关注每一次赋值的变化。// 验证 willSet 和 didSet 作用// 内置变量：newValue oldValuevar name: String = \"tt\" &#123; // newValue willSet&#123; print(\"父类 willSet 被调用, newValue\\(newValue)\") &#125; // oldValue didSet&#123; print(\"父类 didSet 被调用, oldValue\\(oldValue)\") &#125;&#125;权限控制关键字Keyword：openDescription：公开权限，最高权限级别。可以被其他 Module 访问、继承、复写。只能用于类和类的成员Note：由于其具有复写的特性，而 let「常量」属性隐式为 final, 不可复写，所以 open 不能应用到 let 属性上。open class Person &#123; open var name: String? open func talking() -&gt; String &#123; return \"\" &#125;&#125;Keyword: publicDescription：公有访问权限, 类或者类的公有属性或者公有方法可以从文件或者模块的任何地方进行访问. 一个App就是一个模块, 一个第三方API、第三方框架等都是一个完整的模块, 这些模块如果要对外留有访问的属性或者方法, 就应该使用public的访问权限. public的权限在Swift 3.0后无法在其它模块被复写方法/属性或被继承.public class Person &#123; public var name: String? public let uid: String = UUID().uuidString public func talking() -&gt; String &#123; return \"\" &#125;&#125;Keyword: internalDescription: 在模块内部可以访问, 超出模块内部就不可被访问了. 在Swift中属隐式权限，如果不特别设置权限级别，默认即为 internalKeyword：fileprivateDescription：文件私有访问权限, 被fileprivate修饰的类或者类的属性或方法可以在同一个物理文件中访问. 如果超出该物理文件, 那么有这fileprivate访问权限的类、属性和方法就不能被访问了.class ClassModel &#123; init() &#123; let student = Student() let studentName = student.name //只有此文件内可访问 &#125;&#125;fileprivate class Student &#123; fileprivate var name: String = \"\" private var age: Int = 12 // 外部不可访问&#125;Keyword：privateDescription：私有访问权限, 被private修饰的类或者类的属性或方法可以在同一个物理文件中的同一个类型(包含extension)访问. 如果超出物理文件或不属于同一类型, 那么有着private访问权限的属性和方法就不能被访问.private class Student &#123; private let uid = UUID().uuidString private var name: String? private func taking() -&gt; String &#123; return \"hello\" &#125;&#125;类型范围作用域关键字Keyword: staticDescription: 用来修饰类型「class / struct / enum」的属性或方法。static具有以下特性：static可以修饰计算属性、存储属性、类型方法。在 protocol中，如果需要，要使用 static 进行修饰。static 修饰的属性/方法具有隐式的 final 特性，因此不能够继承。静态属性具有实例内存共享特性struct Point &#123; let x: Double let y: Double // 存储属性 static let zero = Point(x: 0, y: 0) // 计算属性 static var ones: [Point] &#123; return [ Point(x: 1, y: 1), Point(x: -1, y: 1), Point(x: 1, y: -1), Point(x: -1, y: -1) ] &#125; // 类型方法 static func add(p1: Point, p2: Point) -&gt; Point &#123; return Point(x: p1.x + p2.x, y: p1.y + p2.y) &#125; &#125;Keyword：classDescription：只能用来修饰类方法，计算属性。在 protocol 中，不可以使用 class 来修饰。class 修饰的类方法，可以继承。class MyClass &#123; //修饰计算属性 class var age: Int &#123; return 10 &#125; // 修饰类方法 class func testFunc() &#123; &#125;&#125;逻辑运算关键字Keyword： if，elselet number = 1if number &gt; 1 &#123; print(\"greating many times\")&#125; else if number &lt; 1 &#123; print(\"not greating\")&#125; else &#123; print(\"greating one times\")&#125;Keyword：forlet numbers: [Int] = [1, 2]for index in 0..&lt;numbers.count &#123; print(\"number = \\(numbers[index])\")&#125;Keyword: switch， case， default，fallthroughenum GenderValue: Int &#123; case male case female&#125;switch gender &#123; case .male: print(\"The gender value is \\(.male.rawValue)\") case .female: print(\"The gender value is \\(.female.rawValue)\") default: break&#125;var index = 10switch index &#123; case 100 : print( \"index 的值为 100\") fallthrough case 10,15 : print( \"index 的值为 10 或 15\") fallthrough case 5 : print( \"index 的值为 5\") default : print( \"默认 case\")&#125;// index 的值为 10 或 15// index 的值为 5Keyword: repeat，while// 在使用循环的判断条件之前，先执行一次循环中的代码。repeat &#123; // do something&#125; while n &gt; 0while n &lt; 0 &#123; // do something &#125;Keyword：whereDescription：可以用来设置约束条件、限制类型，让代码更加简洁、易读。 参考/// switch语句中使用scores.forEach &#123; switch $0 &#123; case let x where x&gt;=60: print(\"及格\") default: print(\"不及格\") &#125;&#125; /// for语句中使用for score in scores where score&gt;=60 &#123; print(\"这个是及格的：\\(score)\")&#125;/// 在 do catch 里面使用enum ExceptionError: Error &#123; case httpCode(Int)&#125; func throwError() throws &#123; throw ExceptionError.httpCode(500)&#125; do&#123; try throwError()&#125;catch ExceptionError.httpCode(let httpCode) where httpCode &gt;= 500 &#123; print(\"server error\")&#125;catch &#123; print(\"other error\")&#125;/// 与协议结合protocol aProtocol&#123;&#125; //只给遵守myProtocol协议的UIView添加了拓展extension aProtocol where Self: UIView &#123; func getString() -&gt; String&#123; return \"string\" &#125;&#125;/// 可以在 associatedtype 后面声明的类型后追加 where 约束语句protocol Sequence &#123; associatedtype Element where Self.Element == Self.Iterator.Element // ...&#125;/// Sequence，Collection 同样新增了 where 语句约束extension Sequence where Element: Numeric &#123; var sum: Element &#123; var result: Element = 0 for item in self &#123; result += item &#125; return result &#125;&#125;extension Collection where Element: Equatable &#123; func prefieIsEqualSuffix(_ n: Int) -&gt; Bool &#123; let head = prefix(n) let suff = suffix(n).reversed() return head.elementsEqual(suff) &#125;&#125;Keyword：guardDescription： 详见func updateWatchApplicationContext() &#123; let session = WCSession.defaultSession() guard session.watchAppInstalled else &#123; return &#125; do &#123; let context = [\"token\": api.token] try session.updateApplicationContext(context) &#125; catch &#123; print(error) &#125;&#125;Keyword：returnDescription：方法返回值func greet(person: String) -&gt; String &#123; let greeting = \"Hello, \" + person + \"!\" return greeting&#125;Keyword：breakDescription：立刻结束整个控制流的执行。如果是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。import Cocoavar index = 10repeat&#123; index = index + 1 if( index == 15 )&#123; // index 等于 15 时终止循环 break &#125; print( \"index 的值为 \\(index)\")&#125;while index &lt; 20Keyword: continueDescription：一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do…while 循环，continue 语句重新执行条件判断语句。import Cocoa var index = 10repeat&#123; index = index + 1 if( index == 15 )&#123; // index 等于 15 时跳过 continue &#125; print( \"index 的值为 \\(index)\")&#125;while index &lt; 20Keyword：in/// 闭包中&#123; (s:String)-&gt;() in // body&#125;/// for-in 循环import Cocoafor index in 1...5 &#123; print(\"\\(index) 乘于 5 为：\\(index * 5)\")&#125;Keyword: deferDescription: 详见func operateOnFile(descriptor: Int32) &#123; let fileHandle = FileHandle(fileDescriptor: descriptor) defer &#123; fileHandle.closeFile() &#125; let data = fileHandle.readDataToEndOfFile() if /* onlyRead */ &#123; return &#125; let shouldWrite = /* 是否需要写文件 */ guard shouldWrite else &#123; return &#125; fileHandle.seekToEndOfFile() fileHandle.write(someData)&#125;异常处理关键字Keyword：do，try, catch，throw，throws，rethrowsDescription: 参考1，参考2类型相关的关键字Keyword：Any,as，is，nil， super，self， Self, Type/// Any：用于表示任意类型的实例，包括函数类型。var anything = [Any]()anything.append(\"Any Swift type can be added\") anything.append(0) anything.append(&#123;(foo: String) -&gt; String in \"Passed in (foo)\"&#125;)/// as：类型转换运算符，用于尝试将值转成其它类型。let intInstance = anything[1] as? Int/// is：类型检查运算符，用于确定实例是否为某个子类类型。class Person &#123;&#125; class Programmer : Person &#123;&#125; class Nurse : Person &#123;&#125;let people = [Programmer(), Nurse()]for aPerson in people &#123; if aPerson is Programmer &#123; print(\"This person is a dev\") &#125; else if aPerson is Nurse &#123; print(\"This person is a nurse\") &#125; &#125;/// nil：在 Swift 中表示任意类型的无状态值。与 Objective-C 中的 nil 不同，Objective-C 中的 nil 表示指向不存在对象的指针。//任何 Swift 类型或实例可以为 nilvar statelessPerson:Person? = nil var statelessPlace:Place? = nil var statelessInt:Int? = nil var statelessString:String? = nil/// super：在子类中，暴露父类的方法、属性、下标。class Person &#123; func printName() &#123; print(\"Printing a name. \") &#125; &#125;class Programmer : Person &#123; override func printName() &#123; super.printName() print(\"Hello World!\") &#125; &#125;let aDev = Programmer() aDev.printName() //打印 Printing a name. Hello World!/// self：任何类型的实例都拥有的隐式属性，等同于实例本身。此外还可以用于区分函数参数和成员属性名称相同的情况。class Person &#123; func printSelf() &#123; print(\"This is me: (self)\") &#125; &#125;let aPerson = Person() aPerson.printSelf() //打印 \"This is me: Person\"/// Self：在协议中，表示遵守当前协议的实体类型。protocol Printable &#123; func printTypeTwice(otherMe:Self) &#125;struct Foo : Printable &#123; func printTypeTwice(otherMe: Foo) &#123; print(\"I am me plus (otherMe)\") &#125; &#125;let aFoo = Foo() let anotherFoo = Foo()aFoo.printTypeTwice(otherMe: anotherFoo) //打印 I am me plus Foo()/// Type：表示任意类型的类型，包括类类型、结构类型、枚举类型、协议类型。class Person &#123;&#125; class Programmer : Person &#123;&#125;let aDev:Programmer.Type = Programmer.self自定义运算符相关的关键字Keyword：left，right, prefix， postfix，infix，operator，associativity， precedenceDescription： 参考Keyword: noneDescription: 一个没有结合性的运算符。不允许这样的运算符相邻出现。// \"&lt;\" 是非结合性的运算符1 &lt; 2 &lt; 3 //编译失败内存管理相关的关键字Keyword: weak, unowned/// unowned：让循环引用中的实例 A 不要强引用实例 B。前提条件是实例 B 的生命周期要长于 A 实例。class Person &#123; var occupation:Job? &#125;//当 Person 实例不存在时，job 也不会存在。job 的生命周期取决于持有它的 Person。class Job &#123; unowned let employee:Person init(with employee:Person) &#123; self.employee = employee &#125; &#125;/// weak：允许循环引用中的实例 A 弱引用实例 B ，而不是强引用。实例 B 的生命周期更短，并会被先释放。class Person &#123; var residence:House? &#125;class House &#123; weak var occupant:Person? &#125;var me:Person? = Person() var myHome:House? = House()me!.residence = myHome myHome!.occupant = meme = nil myHome!.occupant // myHome 等于 nil以#开头的关键字/// #available：基于平台参数，通过 if，while，guard 语句的条件，在运行时检查 API 的可用性。if #available(iOS 10, *) &#123; print(\"iOS 10 APIs are available\") &#125;/// #colorLiteral：在 playground 中使用的字面表达式，用于创建颜色选取器，选取后赋值给变量。let aColor = #colorLiteral //创建颜色选取器/// #column：一种特殊的字面量表达式，用于获取字面量表示式的起始列数。class Person &#123; func printInfo() &#123; print(\"Some person info - on column (#column)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - on column 53/// #else：条件编译控制语句，用于控制程序在不同条件下执行不同代码。与 #if 语句结合使用。当条件为 true，执行对应代码。当条件为 false，执行另一段代码。#if os(iOS) print(\"Compiled for an iOS device\") #else print(\"Not on an iOS device\") #endif/// #elseif：条件编译控制语句，用于控制程序在不同条件下执行代码。与 #if 语句结合使用。当条件为 true，执行对应代码。#if os(iOS) print(\"Compiled for an iOS device\") #elseif os(macOS) print(\"Compiled on a mac computer\") #endif/// #endif：条件编译控制语句，用于控制程序在不同条件下执行代码。用于表明条件编译代码的结尾。#if os(iOS) print(\"Compiled for an iOS device\") #endif/// #file：特殊字面量表达式，返回当前代码所在源文件的名称。class Person &#123; func printInfo() &#123; print(\"Some person info - inside file (#file)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - inside file /*代码所在 playground 文件路径*//// #fileReference：playground 字面量语法，用于创建文件选取器，选取并返回 NSURL 实例。let fontFilePath = #fileReference //创建文件选取器/// #function：特殊字面量表达式，返回函数名称。在方法中，返回方法名。在属性的 getter 或者 setter 中，返回属性名。在特殊的成员中，比如 init 或 subscript 中，返回关键字名称。在文件的最顶层时，返回当前所在模块名称。class Person &#123; func printInfo() &#123; print(\"Some person info - inside function (#function)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - inside function printInfo()/// #if：条件编译控制语句，用于控制程序在不同条件下编译代码。通过判断条件，决定是否执行代码。#if os(iOS) print(\"Compiled for an iOS device\") #endif/// #imageLiteral：playground 字面量语法，创建图片选取器，选择并返回 UIImage 实例。let anImage = #imageLiteral //在 playground 文件中选取图片/// #line：特殊字面量表达式，用于获取当前代码的行数。class Person &#123; func printInfo() &#123; print(\"Some person info - on line number (#line)\") &#125; &#125;let aPerson = Person() aPerson.printInfo() //Some person info - on line number 5/// #selector：用于创建 Objective-C selector 的表达式，可以静态检查方法是否存在，并暴露给 Objective-C。//静态检查，确保 doAnObjCMethod 方法存在 control.sendAction(#selector(doAnObjCMethod), to: target, forEvent: event)/// #sourceLocation：行控制语句，可以指定与原先完全不同的行数和源文件名。通常在 Swift 诊断、debug 时使用。#sourceLocation(file:\"foo.swift\", line:6)/// 打印新值print(#file) print(#line)// 重置行数和文件名#sourceLocation()print(#file) print(#line)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://davidxiaoshuo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://davidxiaoshuo.github.io/tags/swift/"}]},{"title":"IjkPlayer 从编译集成到简单音频播放器的封装 [Android & iOS] 一","slug":"audio/ijkplayer_01","date":"2019-11-20T09:33:38.617Z","updated":"2021-06-19T09:10:50.449Z","comments":true,"path":"audio/ijkplayer_01/","link":"","permalink":"http://davidxiaoshuo.github.io/audio/ijkplayer_01/","excerpt":"","text":"编译篇【Android】背景IjkPlayer 是 bilibili 团队出品的一款基于 FFmpeg 的轻量级的音视频播放器。官方地址： ijkplayer由于我所在项目需要一款音频播放器，所以后面都是基于这个大前提来做的。环境准备编译环境：macOS所需要工具：homebrew 【软件包管理器】, git 【分散式版本控制工具】, yasm 【汇编编译器】# 安装 homebrewruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"# 安装 gitbrew install git# 安装 yasmbrew install yasm配置环境变量：# add these lines to your ~/.bash_profile or ~/.profile or ~/.zshrc (取决于你使用的终端工具)export ANDROID_SDK=&lt;your sdk path&gt;export ANDROID_NDK=&lt;your ndk path&gt; 【最好区别于你的开发环境变量配置】Note： 由于 ijkplayer 代码比较古老了，NDK 环境最好选择 14 版本。 NDK 下载链接编译通过 git 将 ijkplayer 源码 clone 到本地git clone https://github.com/bilibili/ijkplayer.git &lt;you local path&gt;下载 FFmpeg./init-android.sh下载 OpenSSL, 增加 https 支持./init-android-openssl.sh编译 OpenSSLcd android/contrib./compile-openssl.sh clean./compile-openssl.sh all编译 FFmpegcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh all编译 ijkplayercd android./compile-ijk.sh clean./compile-ijk.sh allNote: 编译说明：compile-openssl.sh &amp; compile-ffmpeg.sh &amp; compile-ijk.sh 后面的参数代表要变哪个CPU架构的版本，默认是 armv7a；armv5 armv7a arm64 x86 x86_64(指定编译哪个版本)all32（所有32位处理器版本，包含armv5 armv7a x86all （所有通用版本，包含armv5 armv7a arm64 x86 x86_64)clean （清除之前编译的缓存）check (检测支持的版本)编译 FFmpeg 说明编译 ffmpeg 时，根据自己的需求来确定你需要的是更多的 codec/format, 还是轻量级的 codec/format 就可以了。【官方文档有描述。后面将会专门讲配置特定需求的 codec/format】if you prefer more codec/formatcd configrm module.shln -s module-default.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh cleanif you prefer less codec/format for smaller binary size (include hevc function) 【hevc: HEVC是High Efficiency Video Coding的缩写，是一种新的视频压缩标准，用来以替代H.264/AVC编码标准，2013年1月26号，HEVC正式成为国际标准。】cd configrm module.shln -s module-lite-hevc.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh cleanif you prefer less codec/format for smaller binnary size (by default)cd configrm module.shln -s module-lite.sh module.shcd android/contrib# cd iossh compile-ffmpeg.sh clean编译中遇到的问题NDK 版本引起的问题，强烈建议选择 r14b 版本，上面有 ndk 下载链接确认你的 NDK 版本是否大于等于 r10ecat $ANDROID_NDK/source.propertiesPkg.Desc = Android NDKPkg.Revision = 14.1.3816874 // 我的NDK版本确定了你的 NDK 版本符合要求，还是报了如下错误You need the NDKr10e or later那么你就要需要修改如下代码, 把你的版本添加进版本检查中：cd android/contrib/toolvim do-detect-env.shIJK_NDK_REL=$(grep -o '^Pkg\\.Revision.*=[0-9]*.*' $ANDROID_NDK/source.properties 2&gt;/dev/null | sed 's/[[:space:]]*//g' | cut -d \"=\" -f 2)echo \"IJK_NDK_REL=$IJK_NDK_REL\"case \"$IJK_NDK_REL\" in 11*|12*|13*|14*|15*|20*) if test -d $&#123;ANDROID_NDK&#125;/toolchains/arm-linux-androideabi-4.9 then echo \"NDKr$IJK_NDK_REL detected\" else echo \"You need the NDKr10e or later\" exit 1 fi ;; *) echo \"You need the NDKr10e or later\" exit 1 ;;由于 ndk 兼容问题导致 standalone toolchain， 如果 macOS 遇到这个问题，可以将使用 r14b 版本的 NDK； 参考链接====================[*] check archs====================FF_ALL_ARCHS = armv5 armv7a arm64 x86 x86_64FF_ACT_ARCHS = armv5 armv7a arm64 x86 x86_64--------------------[*] make NDK standalone toolchain--------------------build on Darwin x86_64ANDROID_NDK=/Users/davidxiaoshuo/Documents/dev_tools/android/sdk/ndk-bundleIJK_NDK_REL=20.0.5594570NDKr20.0.5594570 detected--------------------[*] make NDK standalone toolchain--------------------build on Darwin x86_64ANDROID_NDK=/Users/davidxiaoshuo/Documents/dev_tools/android/sdk/ndk-bundleIJK_NDK_REL=20.0.5594570NDKr20.0.5594570 detectedHOST_OS=darwinHOST_EXE=HOST_ARCH=x86_64HOST_TAG=darwin-x86_64HOST_NUM_CPUS=12BUILD_NUM_CPUS=24Auto-config: --arch=armERROR: Failed to create toolchain.其他方面导致的问题编译模型脚本 （module.sh）导致的问题WARNING: arm-linux-androideabi-pkg-config not found, library detection may fail.--------------------[*] compile ffmpeg--------------------In file included from ./libavutil/internal.h:42:0, from ./libavutil/common.h:467, from ./libavutil/avutil.h:296, from ./libavutil/opt.h:31, from libavfilter/af_adelay.c:22:./libavutil/timer.h:38:31: fatal error: linux/perf_event.h: No such file or directory # include &lt;linux/perf_event.h&gt; ^compilation terminated.In file included from ./libavutil/internal.h:42:0, from ./libavutil/common.h:467, from ./libavutil/avutil.h:296, from libavfilter/avfilter.h:41, from libavfilter/audio.h:25, from libavfilter/af_acopy.c:19:./libavutil/timer.h:38:31: fatal error: linux/perf_event.h: No such file or directory # include &lt;linux/perf_event.h&gt;可以在 module.sh 最后添加 export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot; 这行代码。 参考链接","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"audio","slug":"audio","permalink":"http://davidxiaoshuo.github.io/tags/audio/"}]},{"title":"Android Jni 一","slug":"android/android_jni_one","date":"2019-08-26T13:25:35.835Z","updated":"2021-06-19T09:10:51.472Z","comments":true,"path":"android/android_jni_one/","link":"","permalink":"http://davidxiaoshuo.github.io/android/android_jni_one/","excerpt":"","text":"通过 Android Studio 创建一个 Native C++ 的工程本文中选用 C++11 进行开发","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"Android Studio Gradle's Logger","slug":"android/android_gradle_logger","date":"2019-08-23T01:21:06.375Z","updated":"2021-06-19T09:10:12.523Z","comments":true,"path":"android/android_gradle_logger/","link":"","permalink":"http://davidxiaoshuo.github.io/android/android_gradle_logger/","excerpt":"","text":"前言: 我们在通过 Android Studio 进行 android 开发的时候，难免需要在进行 Gradle 编译构建的时候需要输出一些信息来辅助我们进行配置调试，或是需要输出一些必要信息来提醒其他开发者，此时，我们就要了解下 gradle 的 log 打印相关辅助工具类了。补充：Gradle -&gt; 构建系统工具，它的 DSL 基于 Groovy 实现日志级别级别用途ERROR错误信息QUIET重要信息WARNING警告信息LIFECYCLE进度信息INFO内容信息DEBUG调试信息package org.gradle.api.logging;/** * The log levels supported by Gradle. */public enum LogLevel &#123; DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR&#125;日志开关选项开关选项输出的日志级别无选项LIFECYCLE及更高级别-q 或 --quietQUIRT及更高级别-i 或 --infoINFO及更高级别-d 或 --debugDEBUG及更高级别(全部日志)// 输出 INFO及更高级别的日志gradle -i task提醒： Android Studio 默认情况开启的是LIFECYCLE及更高级别, 所以此时在通过 Android Studio 进行默认 Build 操作时，此时在 Build Output 控制台打印出来的是这个级别的，Info，Debug Log 并不会输出在 gradle 中尝试打印Loglogger.error('this is log of gradle, level ---&gt; error')logger.quiet('this is log of gradle, level ---&gt; quiet')logger.warn('this is log of gradle, level ---&gt; warn')logger.lifecycle('this is log of gradle, level ---&gt; lifecycle')logger.info('this is log of gradle, level ---&gt; info')logger.debug('this is log of gradle, level ---&gt; debug')在验证时，通过 -d 得到以下输出，验证 Log 级别10:01:42.029 [ERROR] [org.gradle.api.Project] this is log of gradle, level ---&gt; error10:01:42.029 [QUIET] [org.gradle.api.Project] this is log of gradle, level ---&gt; quiet10:01:42.029 [WARN] [org.gradle.api.Project] this is log of gradle, level ---&gt; warn10:01:42.029 [LIFECYCLE] [org.gradle.api.Project] this is log of gradle, level ---&gt; lifecycle10:01:42.029 [INFO] [org.gradle.api.Project] this is log of gradle, level ---&gt; info10:01:42.029 [DEBUG] [org.gradle.api.Project] this is log of gradle, level ---&gt; debugprintf 在 gradle 中也是可以再 Build Output 控制台中输出 Log 的10:07:24.545 [QUIET] [system.out] this is log of gradle, event ---&gt; printf","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"}]},{"title":"Android JNI 层 Log 输出","slug":"android/jni_logger","date":"2019-08-11T13:46:12.315Z","updated":"2021-06-19T09:10:24.542Z","comments":true,"path":"android/jni_logger/","link":"","permalink":"http://davidxiaoshuo.github.io/android/jni_logger/","excerpt":"","text":"概述：android 中在进行一些 C++ 底层库开发的时候难免需要一些 log 来辅助我们的开发调试，或是打印一些重要信息给到 Lib 库的使用者。在 android 中，通过 C++ 层的 print Or std::cout 是无法在logcat 中正常显示 log 信息的。android NDK 专门提供了相关的 Logging 工具。__android_log_print 主要使用的函数int __android_log_print( int prio, //优先级 const char *tag, //标签 const char *fmt, // format log string ...)cmake 编译， 在 CMakeLists.txt 中配置需要依赖的 Log 系统库#查找要依赖的系统库find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )#指定要生成的动态库所依赖的库（系统库，外部第三方库）target_link_libraries( # Specifies the target library. # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; )通过对 __android_log_print 稍加修改，来使 log 输出变得更加简单首先要引入所需的头文件 #include &lt;android/log.h&gt;#include &lt;android/log.h&gt;#define TAG \"ProjectName\" // 这个是自定义的LOG的标识 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型，在 Release 模式下禁用 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型 #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型 #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型使用char* log_example_str = \"hello logger\";LOGD(\"This is a log, the content is %s\", log_example_str);LOGI(\"This is a log, the content is %s\", log_example_str);LOGW(\"This is a log, the content is %s\", log_example_str);LOGE(\"This is a log, the content is %s\", log_example_str);LOGF(\"This is a log, the content is %s\", log_example_str);","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"","slug":"menu","date":"2019-08-09T11:17:00.068Z","updated":"2021-06-18T11:33:25.096Z","comments":true,"path":"menu/","link":"","permalink":"http://davidxiaoshuo.github.io/menu/","excerpt":"","text":"Techandroidandroid studio cmake 编译常规设置Android Jni 层 Log 输出c++C++ 中 基础类型转换成 char*macos 远程硬盘挂载USB 转串口工具 minicom SetupgitGit 多github（gitlab）账号管理othersHexo Page 简单发布流程MacOS Terminal 美化 【程序猿推荐】Life","categories":[],"tags":[]},{"title":"USB 转串口工具 minicom Setup","slug":"others/minicom_setup","date":"2019-08-05T06:11:26.384Z","updated":"2021-06-19T09:09:23.762Z","comments":true,"path":"others/minicom_setup/","link":"","permalink":"http://davidxiaoshuo.github.io/others/minicom_setup/","excerpt":"","text":"准备工作安装 minicom 串口调试工具, 通过 Homebrew 安装即可brew install minicomSetup将串口线连接到电脑USB上，查看当前命令行查看连接的串口号ls /dev/tty*上图中的 /dev/tty.usbserial-14340 就是 USB 的串口号将串口号配置给串口工具 minicom命令打开串口工具minicom -s通过键盘上的 J, K 或者方向键上下移动到 Serial port setup 选项，按回车选中，进入串口设置界面通过键盘上的大写字母 A 选中进入 Serial Device 选项，并将之前复制好的串口号粘贴在此，并按两次回车, 回到主 Setup 界面。定位到 Save setup as dfl 回车并选中。定位到 Exit 退出 Setup 界面到 串口命令终端中 或 定位到 Exit from minicom 退回到系统命令界面","categories":[{"name":"DevEnv","slug":"DevEnv","permalink":"http://davidxiaoshuo.github.io/categories/DevEnv/"}],"tags":[{"name":"env","slug":"env","permalink":"http://davidxiaoshuo.github.io/tags/env/"}]},{"title":"macos 远程硬盘挂载","slug":"others/macos_remote_disk_mount","date":"2019-08-05T06:08:40.805Z","updated":"2021-06-19T09:09:18.210Z","comments":true,"path":"others/macos_remote_disk_mount/","link":"","permalink":"http://davidxiaoshuo.github.io/others/macos_remote_disk_mount/","excerpt":"","text":"准备工作安装Homebrew, 具体安装方式，见官网通过Homebrew 安装 sshfs 的依赖 fusebrew install Caskroom/cask/osxfuse通过Homebrew 安装sshfsbrew install sshfs使用sshfs remote_account@ip:remote_directory /local/directory挂载到本地时，避免挂在到根目录下或者当前账户的主目录下，否则会引起以下错误：mount_osxfuse: mount point /Users/xxxx/ImageFolder is itself on a OSXFUSE volumefuse: failed to mount file system: Invalid argument","categories":[{"name":"DevEnv","slug":"DevEnv","permalink":"http://davidxiaoshuo.github.io/categories/DevEnv/"}],"tags":[{"name":"env","slug":"env","permalink":"http://davidxiaoshuo.github.io/tags/env/"}]},{"title":"Home Page","slug":"home","date":"2019-08-04T14:55:28.419Z","updated":"2021-06-19T08:48:20.937Z","comments":true,"path":"home/","link":"","permalink":"http://davidxiaoshuo.github.io/home/","excerpt":"","text":"Home PageHi, 这里是我记录我所感兴趣的技术，生活的地方。如果技术上有错误的地方欢迎联系我，并指正。昵称：David小硕职业：移动端技术研发经理主攻技术方向：Android; iOS; C++公司：北京物灵科技有限公司","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]},{"title":"C++ 中 基础类型转换成 char *","slug":"c++/cplus_type_convert","date":"2019-08-04T05:33:15.437Z","updated":"2021-06-19T09:12:46.881Z","comments":true,"path":"c++/cplus_type_convert/","link":"","permalink":"http://davidxiaoshuo.github.io/c++/cplus_type_convert/","excerpt":"","text":"C++ 中 基础类型转换成 char*有时候我们在项目中难免会用到，将基础数据类型转换成char*，这样会方面一些业务上的开展。前一阵子做基于mips 平台下 阿里云Log Service时候就用到了，由于考虑要封装sdk的轻量性，所以没有考虑依赖其他的系统库。以下demo 代码依赖如下系统库，#include &lt;stdio.h&gt;#include &lt;string&gt;基础数据类型的相互转换其实有多种方式。以下多是通过 printf 方式来完成的。int 转 char *char* int_to_char_ptr(int src) &#123; char result[30] = \"\"; sprintf(result, \"%d\", src); char* ret_value = result; return ret_value;&#125;double 转 char*char* double_to_char_ptr(double src) &#123; char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xlf sprintf(result, \"%lf\", src); char* ret_value = result; return ret_value;&#125;float 转 char*char* float_to_char_ptr(float src) &#123; char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xf sprintf(result, \"%f\", src); char* ret_value = result; return ret_value;&#125;size_t 转 char*char* size_t_to_char_ptr(size_t value) &#123; char result[30] = \"\"; sprintf(result, \"%zu\", value); char * ret_value = result; return ret_value;&#125;string 转 char*char* str_to_char_array(std::string value) &#123; return const_cast&lt;char*&gt;(value.c_str());&#125;char* 转 stringstd::string char_ptr_to_str(const char* value) &#123; std::string res; res = value; return res;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://davidxiaoshuo.github.io/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://davidxiaoshuo.github.io/tags/c/"}]},{"title":"MacOS Terminal 美化 【程序猿推荐】","slug":"others/macos_terminal_themes","date":"2019-05-11T07:51:02.823Z","updated":"2021-06-19T09:09:07.802Z","comments":true,"path":"others/macos_terminal_themes/","link":"","permalink":"http://davidxiaoshuo.github.io/others/macos_terminal_themes/","excerpt":"","text":"MacOS Terminal 美化 【程序猿推荐】工欲善其事，必先利其器我们在MacOS 下开发的时候不可避免一定为会用的terminal，不管你是server端选手，客户端选手，又或者是…哎呀，等等吧，总之terminal是我们在开发中使用评率比较高的基础开发工具了。但是原生的terminal，是一个及其简陋的家伙。那么怎么能让我们的terminal能够看起来既舒服又能超好用呢。动起手来…先晒一张我的terminal截图：改造Terminal步骤安装oh-my-zsh设置 oh-my-zsh 主题安装 oh-my-zsh 日常所需的插件，以提高工作效率修改 Terminal 的Profile，让我们的 Terminal 与 zsh 的主题更加匹配准备工作(可能会需要)首先我们先安装MacOS 中比较好用的软件包管理器 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"安装 oh-my-zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"配置 oh-my-zsh 主题首先我们链接到 oh-my-zsh 主题的页面 --&gt; https://github.com/robbyrussell/oh-my-zsh/wiki/Themes选择我们喜欢的主题，然后记住主题名字，这里我的主题名字是：pygmalion然后我们打开Terminal窗口输入以下命令对 .zshrc 文件进行编辑vim ~/.zshrc// 将 ZSH_THEME 设置为即将要是用的主题名称ZSH_THEME=\"pygmalion\"设置成功后，退出vim。执行以下命令，使刚刚的设置生效：source ~/.zshrc如果你细心你会发现实际上oh-my-zsh在安装的时候已经内置了很多的主题。cd ~/.oh-my-zsh/themes // 主题目录cd ~/.oh-my-zsh/plugins // 插件所在目录安装oh-my-zsh插件oh-my-zsh 的插件有很多，它本身内置的插件也有很多，但是我们在用的时候可以根据需要设置需要的即可。因为插件安装过多，一定程度上会使zsh的命令执行效率变低zsh-syntax-highlightingzsh 语法高亮插件，官方地址vim ~/.zshrc//添加如下脚本plugins=( git zsh-syntax-highlighting)安装效果如下：修改 Terminal 的Profile，导入我们想要的主题 【我选择的是Fideloper】macos-terminal-themes 提供了丰富的主题供我们选择，我们可以在当中找一款与我们所选zsh主题相符合的主题。将 macos-terminal-themes 下载到本地进入到 schemes 目录下双击 *.terminal 的文件，将会打开一个所选主题的新的Terminal窗口选择Terminal 工具栏中的 Shell -&gt; Use Setting as Default, 即将主题修改为所选主题。","categories":[{"name":"Other","slug":"Other","permalink":"http://davidxiaoshuo.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://davidxiaoshuo.github.io/tags/other/"}]},{"title":"android studio cmake 编译常规设置","slug":"android/cmake_list","date":"2019-04-24T04:01:45.000Z","updated":"2021-06-19T09:10:53.032Z","comments":true,"path":"android/cmake_list/","link":"","permalink":"http://davidxiaoshuo.github.io/android/cmake_list/","excerpt":"","text":"add_executable 指令语法：add_executable(executable_file_name [source])将一组源文件 source 生成一个可执行文件。 source 可以是多个源文件，也可以是对应定义的变量 如：add_executable(hello main.c)cmake_minimun_required(VERSION 3.4.1)用来指定 CMake 最低版本为3.4.1，如果没指定，执行 cmake 命令时可能会出错add_subdirectory 指令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数含义是将这个目录从编译过程中排除。另外，也可以通过 SET 指令重新定义EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置 (指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件)set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)add_library 指令语法：add_library(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])将一组源文件 source 编译出一个库文件，并保存为 libname.so (lib 前缀是生成文件时 CMake自动添加上去的)。其中有三种库文件类型，不写的话，默认为 STATIC:SHARED: 表示动态库，可以在(Java)代码中使用System.loadLibrary(name)动态调用；STATIC: 表示静态库，集成到代码中会在编译时调用；MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待；EXCLUDE_FROM_ALL: 表示这个库不被默认构建，除非其他组件依赖或手工构建#将compress.c 编译成 libcompress.so 的共享库add_library(compress SHARED compress.c)add_library 命令也可以用来导入第三方的库:add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED) 如，导入 libjpeg.soadd_library(libjpeg SHARED IMPORTED)导入库后，当需要使用 target_link_libraries 链接库时，可以直接使用该库find_library 指令语法：find_library(name1 path1 path2 …)VAR 变量表示找到的库全路径，包含库文件名 。例如：find_library(libX X11 /usr/lib)find_library(log-lib log)#路径为空，应该是查找系统环境变量路径set_target_properties 指令语法:set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），对于动态库，还可以用来指定动态库版本和 API 版本。如: set_target_properties(hello_static PROPERTIES OUTPUT_NAME “hello”) 设置同名的 hello 动态库和静态库：set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)set_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)指定要导入的库文件的路径add_library(jpeg SHARED IMPORTED)#注意要先 add_library，再 set_target_propertiesset_target_properties(jpeg PROPERTIES IMPORTED_LOCATION $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libjpeg.so)设置动态库 hello 版本和 API 版本：set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)和它对应的指令：get\\_target_property(VAR target property)。如上面的例子，获取输出的库的名字get_target_property(OUTPUT_VALUE hello_static OUTPUT_NAME)message(STATUS \"this is the hello_static OUTPUT_NAME:\"$&#123;OUTPUT_VALUE&#125;)include_directories 指令语法：include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)这个指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。target_link_libraries 指令语法：target_link_libraries(target library library2…)这个指令可以用来为 target 添加需要的链接的共享库，同样也可以用于为自己编写的共享库添加共享库链接。如：#指定 compress 工程需要用到 libjpeg 库和 log 库target_link_libraries(compress libjpeg $&#123;log-lib&#125;)同样，link_directories(directory1 directory2 …) 可以添加非标准的共享库搜索路径。还有其他 file、list、install 、find_ 指令和控制指令等就不介绍了，详细可以查看手册。CMake 的常用变量变量引用方式使用 ${} 进行变量的引用。不过在 IF 等语句中，可以直接使用变量名而不用通过 ${} 取值自定义变量的方式主要有隐式定义和显式定义两种。隐式定义，如 PROJECT 指令会隐式定义_BINARY_DIR 和_SOURCE_DIR而对于显式定义就是通过 SET 指令来定义。如：set(HELLO_SRC main.c)CMake 常用变量CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, _BINARY_DIR这三个变量指代的内容都是一样的，如果是 in-source 编译，指的是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, _SOURCE_DIR这三个变量指代的内容也是一样的，不论哪种编译方式，都是工程顶层目录。CMAKE_CURRENT_SOURCE_DIR当前处理的 CMakeLists.txt 所在的路径CMAKE_CURRENT_BINARY_DIR如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致，如果是 out-of-source 编译，指的是 target 编译目录。使用 ADD_SUBDIRECTORY(src bin)可以修改这个变量的值；而使用 SET(EXECUTABLE_OUTPUT_PATH &amp;lt; 新路径&amp;gt;) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行CMAKE_MODULE_PATH 这个变量用来定义自己的 CMake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。比如：SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。PROJECT_NAME返回通过 PROJECT 指令定义的项目名称。Android CMake 的使用CMakeList.txt 的编写再回归到 Android NDK 开发中 CMake 的使用，先看一个系统生成的 NDK 项目的 CMakeLists.txt 的配置：(去掉原有的注释)# 设置编译 native library 需要最小的 cmake 版本cmake_minimum_required(VERSION 3.4.1)# 将指定的源文件编译为名为 libnative-lib.so 的动态库add_library(native-lib SHARED src/main/cpp/native-lib.cpp)# 查找本地 log 库find_library(log-lib log)# 将预构建的库添加到自己的原生库target_link_libraries(native-lib $&#123;log-lib&#125;)复杂一点的 CMakeLists，这是一个本地使用 libjpeg.so 来做图片压缩的项目cmake_minimum_required(VERSION 3.4.1)#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;)#指定要引用的libjpeg.so的头文件目录set(LIBJPEG_INCLUDE_DIR src/main/cpp/include)include_directories($&#123;LIBJPEG_INCLUDE_DIR&#125;)#导入libjpeg动态库 SHARED；静态库为STATICadd_library(jpeg SHARED IMPORTED)#对应so目录，注意要先 add_library，再 set_target_properties）set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libjpeg.so)add_library(compress SHARED src/main/cpp/compress.c)find_library(graphics jnigraphics)find_library(log-lib log)#添加链接上面个所 find 和 add 的 librarytarget_link_libraries(compress jpeg $&#123;log-lib&#125; $&#123;graphics&#125;)配置 Gradle简单的配置如下，至于 cppFlags 或 cFlags 的参数有点复杂，一般设置为空或不设置也是可以的，这里就不过多介绍了android &#123;compileSdkVersion 25buildToolsVersion \"25.0.3\"defaultConfig &#123; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName \"1.0\" externalNativeBuild &#123; cmake &#123; // Passes optional arguments to CMake. arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\" // Sets optional flags for the C compiler. cFlags \"-D_EXAMPLE_C_FLAG1\",\"-D_EXAMPLE_C_FLAG2\" // Sets a flag to enable format macro constants for the C++ compiler. cppFlags \"-D__STDC_FORMAT_MACROS\" //生成.so库的目标平台 abiFilters 'x86','x86_64','armeabi','armeabi-v7a','arm64-v8a' &#125; &#125;&#125;//配置 CMakeLists.txt 路径externalNativeBuild &#123; cmake &#123; path \"CMakeLists.txt\" &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://davidxiaoshuo.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"},{"name":"jni","slug":"jni","permalink":"http://davidxiaoshuo.github.io/tags/jni/"}]},{"title":"Git 多github（gitlab）账号管理","slug":"git/git_multi_account_manager","date":"2019-04-23T08:31:52.000Z","updated":"2021-06-19T09:12:00.558Z","comments":true,"path":"git/git_multi_account_manager/","link":"","permalink":"http://davidxiaoshuo.github.io/git/git_multi_account_manager/","excerpt":"","text":"场景：很多时候我们有公司的github的账号同时自己私下还可能会有多个git平台的账号（如：github，gitlab）。这时候在管理git账号，指定哪个项目用哪个账号，放在哪个账户的仓库下，就显得尤为重要了。下面简单说下如何配置git config 文件去管理这些git平台账号。1. 生成ssh-key$ ssh-keygen -t rsa -C \"youremail@company.com” -f ~/.ssh/id-rsaexplain：这样在~/.ssh/目录下就会生成id-rsa和id-rsa.pub的公钥和私钥。其中id-rsa 我们可以根据我们自己的需求来定义名称，例如我的名称personal-github-id-rsa(私人），company-github-id-rsa（公司github），company-gitlab-id-rsa（公司gitlab）。生成ssh-key 后我们可以copy 公钥到各git平台$ pbcopy &lt; ~/.ssh/id-rsa通过上面的命令将公钥copy到剪贴板，然后到git平台的ssh-key页面直接粘贴即可。2. 添加私钥$ ssh-add ~/.ssh/id-rsa将私钥添加到我们本地ssh中# 可以通过 ssh-add -l 来确私钥列表$ ssh-add -l# 可以通过 ssh-add -D 来清空私钥列表$ ssh-add -D3. 创建多账号管理文件touch ~/.ssh/configvim config# gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-gitlab-id-rsa# githubHost github-company HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-github-id-rsa#personal-githubHost github-personal HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/personal-github-rsaexplain: Host 这里可以理解为我们为实际的host（如：github.com）起的别名，HostName才是实际的host address值，这样我们在本地仓库指定远程仓库的时候就可以区分出同一个平台下的不同账号体系了，可以通过下面的remote repository 地址可以看出。4. 为本地仓库指定远程仓库地址4.1 远程仓库地址，从github中直接复制显示：4.2 实际为本地仓库指定远程仓库地址需要这样：添加地址：git remote add origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git重定向地址：git remote set-url origin git@github-personal:Davidxiaoshuo/EmotionCalendar.gitexplain: 其中git@后面的字段为我们在config配置文件中的Host的值","categories":[{"name":"Git","slug":"Git","permalink":"http://davidxiaoshuo.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://davidxiaoshuo.github.io/tags/git/"}]},{"title":"Hello World","slug":"others/hello_world","date":"2019-04-19T07:39:43.000Z","updated":"2021-06-19T09:09:00.111Z","comments":true,"path":"others/hello_world/","link":"","permalink":"http://davidxiaoshuo.github.io/others/hello_world/","excerpt":"","text":"Hexo Page 简单发布流程Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post$ hexo new \"My New Post\"More info: WritingRun server$ hexo serverMore info: ServerGenerate static files$ hexo generateMore info: GeneratingDeploy to remote sites$ hexo deployMore info: Deployment","categories":[{"name":"Other","slug":"Other","permalink":"http://davidxiaoshuo.github.io/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://davidxiaoshuo.github.io/tags/other/"}]}]}
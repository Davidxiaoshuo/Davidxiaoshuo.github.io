{"meta":{"title":"David小硕","subtitle":"write readable code","description":"在这个薄情的世界，深情地活着","author":"David Bo","url":"http://davidxiaoshuo.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-08-14T07:53:34.576Z","updated":"2019-08-14T07:53:34.576Z","comments":false,"path":"about/index.html","permalink":"http://davidxiaoshuo.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-08-14T08:09:24.735Z","updated":"2019-08-14T08:09:24.735Z","comments":false,"path":"categories/index.html","permalink":"http://davidxiaoshuo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-14T07:54:56.780Z","updated":"2019-08-14T07:54:56.779Z","comments":false,"path":"tags/index.html","permalink":"http://davidxiaoshuo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android JNI 层 Log 输出","slug":"android/jni_logger","date":"2019-08-11T13:46:12.315Z","updated":"2019-08-14T08:06:50.702Z","comments":true,"path":"android/jni_logger/","link":"","permalink":"http://davidxiaoshuo.github.io/android/jni_logger/","excerpt":"","text":"概述：android 中在进行一些 C++ 底层库开发的时候难免需要一些 log 来辅助我们的开发调试，或是打印一些重要信息给到 Lib 库的使用者。在 android 中，通过 C++ 层的 print Or std::cout 是无法在logcat 中正常显示 log 信息的。android NDK 专门提供了相关的 Logging 工具。 __android_log_print 主要使用的函数int __android_log_print( int prio, //优先级 const char *tag, //标签 const char *fmt, // format log string ... ) cmake 编译， 在 CMakeLists.txt 中配置需要依赖的 Log 系统库#查找要依赖的系统库 find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) #指定要生成的动态库所依赖的库（系统库，外部第三方库） target_link_libraries( # Specifies the target library. # Links the target library to the log library # included in the NDK. ${log-lib} ) 通过对 __android_log_print 稍加修改，来使 log 输出变得更加简单首先要引入所需的头文件 #include &lt;android/log.h&gt;#include &lt;android/log.h&gt; #define TAG \"ProjectName\" // 这个是自定义的LOG的标识 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型，在 Release 模式下禁用 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型 #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型 #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型 使用char* log_example_str = \"hello logger\"; LOGD(\"This is a log, the content is %s\", log_example_str); LOGI(\"This is a log, the content is %s\", log_example_str); LOGW(\"This is a log, the content is %s\", log_example_str); LOGE(\"This is a log, the content is %s\", log_example_str); LOGF(\"This is a log, the content is %s\", log_example_str);","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"}]},{"title":"menu","slug":"menu","date":"2019-08-09T11:17:00.068Z","updated":"2019-08-14T08:08:09.970Z","comments":true,"path":"menu/","link":"","permalink":"http://davidxiaoshuo.github.io/menu/","excerpt":"","text":"Techandroidandroid studio cmake 编译常规设置Android Jni 层 Log 输出c++C++ 中 基础类型转换成 char*macos 远程硬盘挂载USB 转串口工具 minicom SetupgitGit 多github（gitlab）账号管理othersHexo Page 简单发布流程MacOS Terminal 美化 【程序猿推荐】Life","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]},{"title":"USB 转串口工具 minicom Setup","slug":"c++/minicom_setup","date":"2019-08-05T06:11:26.384Z","updated":"2019-08-14T08:01:53.987Z","comments":true,"path":"c++/minicom_setup/","link":"","permalink":"http://davidxiaoshuo.github.io/c++/minicom_setup/","excerpt":"","text":"准备工作安装 minicom 串口调试工具, 通过 Homebrew 安装即可brew install minicom Setup将串口线连接到电脑USB上，查看当前命令行查看连接的串口号ls /dev/tty* 上图中的 /dev/tty.usbserial-14340 就是 USB 的串口号将串口号配置给串口工具 minicom命令打开串口工具minicom -s 通过键盘上的 J, K 或者方向键上下移动到 Serial port setup 选项，按回车选中，进入串口设置界面通过键盘上的大写字母 A 选中进入 Serial Device 选项，并将之前复制好的串口号粘贴在此，并按***两次***回车, 回到主 Setup 界面。定位到 Save setup as dfl 回车并选中。定位到 Exit 退出 Setup 界面到 串口命令终端中 或 定位到 Exit from minicom 退回到系统命令界面","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://davidxiaoshuo.github.io/tags/c/"}]},{"title":"macos 远程硬盘挂载","slug":"c++/macos_remote_disk_mount","date":"2019-08-05T06:08:40.805Z","updated":"2019-08-14T08:02:18.133Z","comments":true,"path":"c++/macos_remote_disk_mount/","link":"","permalink":"http://davidxiaoshuo.github.io/c++/macos_remote_disk_mount/","excerpt":"","text":"准备工作安装Homebrew, 具体安装方式，见官网通过Homebrew 安装 sshfs 的依赖 fusebrew install Caskroom/cask/osxfuse 通过Homebrew 安装sshfsbrew install sshfs 使用sshfs remote_account@ip:remote_directory /local/directory 挂载到本地时，避免挂在到根目录下或者当前账户的主目录下，否则会引起以下错误：mount_osxfuse: mount point /Users/xxxx/ImageFolder is itself on a OSXFUSE volume fuse: failed to mount file system: Invalid argument","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://davidxiaoshuo.github.io/tags/c/"}]},{"title":"Home Page","slug":"home","date":"2019-08-04T14:55:28.419Z","updated":"2019-08-14T08:07:48.728Z","comments":true,"path":"home/","link":"","permalink":"http://davidxiaoshuo.github.io/home/","excerpt":"","text":"Home PageHi, 这里是我记录我所感兴趣的技术，生活的地方。如果技术上有错误的地方欢迎联系我，并指正。昵称：David小硕职业：移动端技术研发经理主攻技术方向：Android; iOS; C++公司：北京物灵科技有限公司","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]},{"title":"C++ 中 基础类型转换成 char *","slug":"c++/cplus_type_convert","date":"2019-08-04T05:33:15.437Z","updated":"2019-08-14T08:06:18.006Z","comments":true,"path":"c++/cplus_type_convert/","link":"","permalink":"http://davidxiaoshuo.github.io/c++/cplus_type_convert/","excerpt":"","text":"C++ 中 基础类型转换成 char*有时候我们在项目中难免会用到，将基础数据类型转换成char*，这样会方面一些业务上的开展。前一阵子做基于mips 平台下 阿里云Log Service时候就用到了，由于考虑要封装sdk的轻量性，所以没有考虑依赖其他的系统库。 以下demo 代码依赖如下系统库，#include &lt;stdio.h&gt; #include &lt;string&gt; 基础数据类型的相互转换其实有多种方式。以下多是通过 printf 方式来完成的。 int 转 char *char* int_to_char_ptr(int src) { char result[30] = \"\"; sprintf(result, \"%d\", src); char* ret_value = result; return ret_value; } double 转 char*char* double_to_char_ptr(double src) { char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xlf sprintf(result, \"%lf\", src); char* ret_value = result; return ret_value; } float 转 char*char* float_to_char_ptr(float src) { char result[30] = \"\"; // 如果需要保留小数x位数, eg: %.xf sprintf(result, \"%f\", src); char* ret_value = result; return ret_value; } size_t 转 char*char* size_t_to_char_ptr(size_t value) { char result[30] = \"\"; sprintf(result, \"%zu\", value); char * ret_value = result; return ret_value; } string 转 char*char* str_to_char_array(std::string value) { return const_cast&lt;char*&gt;(value.c_str()); } char* 转 stringstd::string char_ptr_to_str(const char* value) { std::string res; res = value; return res; }","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://davidxiaoshuo.github.io/tags/c/"}]},{"title":"MacOS Terminal 美化 【程序猿推荐】","slug":"others/macos_terminal_themes","date":"2019-05-11T07:51:02.823Z","updated":"2019-08-14T08:06:34.946Z","comments":true,"path":"others/macos_terminal_themes/","link":"","permalink":"http://davidxiaoshuo.github.io/others/macos_terminal_themes/","excerpt":"","text":"MacOS Terminal 美化 【程序猿推荐】工欲善其事，必先利其器我们在MacOS 下开发的时候不可避免一定为会用的terminal，不管你是server端选手，客户端选手，又或者是…哎呀，等等吧，总之terminal是我们在开发中使用评率比较高的基础开发工具了。但是原生的terminal，是一个及其简陋的家伙。那么怎么能让我们的terminal能够看起来既舒服又能超好用呢。动起手来… 先晒一张我的terminal截图： 改造Terminal步骤安装oh-my-zsh设置 oh-my-zsh 主题安装 oh-my-zsh 日常所需的插件，以提高工作效率修改 Terminal 的Profile，让我们的 Terminal 与 zsh 的主题更加匹配 准备工作(可能会需要)首先我们先安装MacOS 中比较好用的软件包管理器 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 oh-my-zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 配置 oh-my-zsh 主题首先我们链接到 oh-my-zsh 主题的页面 --&gt; https://github.com/robbyrussell/oh-my-zsh/wiki/Themes选择我们喜欢的主题，然后记住主题名字，这里我的主题名字是：pygmalion然后我们打开Terminal窗口输入以下命令对 .zshrc 文件进行编辑vim ~/.zshrc // 将 ZSH_THEME 设置为即将要是用的主题名称 ZSH_THEME=\"pygmalion\" 设置成功后，退出vim。执行以下命令，使刚刚的设置生效：source ~/.zshrc 如果你细心你会发现实际上oh-my-zsh在安装的时候已经内置了很多的主题。cd ~/.oh-my-zsh/themes // 主题目录 cd ~/.oh-my-zsh/plugins // 插件所在目录 安装oh-my-zsh插件oh-my-zsh 的插件有很多，它本身内置的插件也有很多，但是我们在用的时候可以根据需要设置需要的即可。因为插件安装过多，一定程度上会使zsh的命令执行效率变低 zsh-syntax-highlightingzsh 语法高亮插件，官方地址vim ~/.zshrc //添加如下脚本 plugins=( git zsh-syntax-highlighting ) 安装效果如下： 修改 Terminal 的Profile，导入我们想要的主题 【我选择的是***Fideloper***】macos-terminal-themes 提供了丰富的主题供我们选择，我们可以在当中找一款与我们所选zsh主题相符合的主题。将 macos-terminal-themes 下载到本地进入到 schemes 目录下双击 *.terminal 的文件，将会打开一个所选主题的新的Terminal窗口选择Terminal 工具栏中的 Shell -&gt; Use Setting as Default, 即将主题修改为所选主题。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]},{"title":"android studio cmake 编译常规设置","slug":"android/cmake_list","date":"2019-04-24T04:01:45.000Z","updated":"2019-08-14T08:03:32.402Z","comments":true,"path":"android/cmake_list/","link":"","permalink":"http://davidxiaoshuo.github.io/android/cmake_list/","excerpt":"","text":"add_executable 指令语法：add_executable(executable_file_name [source])将一组源文件 source 生成一个可执行文件。 source 可以是多个源文件，也可以是对应定义的变量 如：add_executable(hello main.c) cmake_minimun_required(VERSION 3.4.1)用来指定 CMake 最低版本为3.4.1，如果没指定，执行 cmake 命令时可能会出错 add_subdirectory 指令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL参数含义是将这个目录从编译过程中排除。另外，也可以通过 SET 指令重新定义EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置 (指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件)set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) add_library 指令语法：add_library(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])将一组源文件 source 编译出一个库文件，并保存为 libname.so (lib 前缀是生成文件时 CMake自动添加上去的)。其中有三种库文件类型，不写的话，默认为 STATIC:SHARED: 表示动态库，可以在(Java)代码中使用System.loadLibrary(name)动态调用；STATIC: 表示静态库，集成到代码中会在编译时调用；MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待；EXCLUDE_FROM_ALL: 表示这个库不被默认构建，除非其他组件依赖或手工构建#将compress.c 编译成 libcompress.so 的共享库 add_library(compress SHARED compress.c) add_library 命令也可以用来导入第三方的库:add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED) 如，导入 libjpeg.soadd_library(libjpeg SHARED IMPORTED) 导入库后，当需要使用 target_link_libraries 链接库时，可以直接使用该库 find_library 指令语法：find_library(name1 path1 path2 …)VAR 变量表示找到的库全路径，包含库文件名 。例如：find_library(libX X11 /usr/lib) find_library(log-lib log) #路径为空，应该是查找系统环境变量路径 set_target_properties 指令语法:set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），对于动态库，还可以用来指定动态库版本和 API 版本。如: set_target_properties(hello_static PROPERTIES OUTPUT_NAME “hello”) 设置同名的 hello 动态库和静态库：set_target_properties(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) set_target_properties(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) 指定要导入的库文件的路径add_library(jpeg SHARED IMPORTED) #注意要先 add_library，再 set_target_properties set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so) 设置动态库 hello 版本和 API 版本：set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)和它对应的指令：get\\_target_property(VAR target property)。如上面的例子，获取输出的库的名字get_target_property(OUTPUT_VALUE hello_static OUTPUT_NAME) message(STATUS &quot;this is the hello_static OUTPUT_NAME:&quot;${OUTPUT_VALUE}) include_directories 指令语法：include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)这个指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。 target_link_libraries 指令语法：target_link_libraries(target library library2…)这个指令可以用来为 target 添加需要的链接的共享库，同样也可以用于为自己编写的共享库添加共享库链接。如：#指定 compress 工程需要用到 libjpeg 库和 log 库 target_link_libraries(compress libjpeg ${log-lib}) 同样，link_directories(directory1 directory2 …) 可以添加非标准的共享库搜索路径。还有其他 file、list、install 、find_ 指令和控制指令等就不介绍了，详细可以查看手册。 CMake 的常用变量变量引用方式使用 ${} 进行变量的引用。不过在 IF 等语句中，可以直接使用变量名而不用通过 ${} 取值自定义变量的方式主要有隐式定义和显式定义两种。隐式定义，如 PROJECT 指令会隐式定义_BINARY_DIR 和_SOURCE_DIR而对于显式定义就是通过 SET 指令来定义。如：set(HELLO_SRC main.c)CMake 常用变量CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, _BINARY_DIR这三个变量指代的内容都是一样的，如果是 in-source 编译，指的是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, _SOURCE_DIR这三个变量指代的内容也是一样的，不论哪种编译方式，都是工程顶层目录。CMAKE_CURRENT_SOURCE_DIR当前处理的 CMakeLists.txt 所在的路径CMAKE_CURRENT_BINARY_DIR如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致，如果是 out-of-source 编译，指的是 target 编译目录。使用 ADD_SUBDIRECTORY(src bin)可以修改这个变量的值；而使用 SET(EXECUTABLE_OUTPUT_PATH &amp;lt; 新路径&amp;gt;) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行CMAKE_MODULE_PATH 这个变量用来定义自己的 CMake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。比如：SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。PROJECT_NAME返回通过 PROJECT 指令定义的项目名称。 Android CMake 的使用 CMakeList.txt 的编写再回归到 Android NDK 开发中 CMake 的使用，先看一个系统生成的 NDK 项目的 CMakeLists.txt 的配置：(去掉原有的注释)# 设置编译 native library 需要最小的 cmake 版本 cmake_minimum_required(VERSION 3.4.1) # 将指定的源文件编译为名为 libnative-lib.so 的动态库 add_library (native-lib SHARED src/main/cpp/native-lib.cpp) # 查找本地 log 库 find_library (log-lib log) # 将预构建的库添加到自己的原生库 target_link_libraries (native-lib ${log-lib}) 复杂一点的 CMakeLists，这是一个本地使用 libjpeg.so 来做图片压缩的项目cmake_minimum_required(VERSION 3.4.1) #设置生成的so动态库最后输出的路径 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}) #指定要引用的libjpeg.so的头文件目录 set(LIBJPEG_INCLUDE_DIR src/main/cpp/include) include_directories(${LIBJPEG_INCLUDE_DIR}) #导入libjpeg动态库 SHARED；静态库为STATIC add_library(jpeg SHARED IMPORTED) #对应so目录，注意要先 add_library，再 set_target_properties） set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ${PROJECT_SOURCE_DIR}/libs/${ANDROID_ABI}/libjpeg.so) add_library(compress SHARED src/main/cpp/compress.c) find_library(graphics jnigraphics) find_library(log-lib log) #添加链接上面个所 find 和 add 的 library target_link_libraries(compress jpeg ${log-lib} ${graphics}) 配置 Gradle简单的配置如下，至于 cppFlags 或 cFlags 的参数有点复杂，一般设置为空或不设置也是可以的，这里就不过多介绍了android { compileSdkVersion 25 buildToolsVersion &quot;25.0.3&quot; defaultConfig { minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; externalNativeBuild { cmake { // Passes optional arguments to CMake. arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot; // Sets optional flags for the C compiler. cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;,&quot;-D_EXAMPLE_C_FLAG2&quot; // Sets a flag to enable format macro constants for the C++ compiler. cppFlags &quot;-D__STDC_FORMAT_MACROS&quot; //生成.so库的目标平台 abiFilters 'x86','x86_64','armeabi','armeabi-v7a','arm64-v8a' } } } //配置 CMakeLists.txt 路径 externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } }","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://davidxiaoshuo.github.io/tags/android/"}]},{"title":"Git 多github（gitlab）账号管理","slug":"git/git_multi_account_manager","date":"2019-04-23T08:31:52.000Z","updated":"2019-08-14T08:04:03.585Z","comments":true,"path":"git/git_multi_account_manager/","link":"","permalink":"http://davidxiaoshuo.github.io/git/git_multi_account_manager/","excerpt":"","text":"场景：很多时候我们有公司的github的账号同时自己私下还可能会有多个git平台的账号（如：github，gitlab）。这时候在管理git账号，指定哪个项目用哪个账号，放在哪个账户的仓库下，就显得尤为重要了。下面简单说下如何配置git config 文件去管理这些git平台账号。 1. 生成ssh-key$ ssh-keygen -t rsa -C &quot;youremail@company.com” -f ~/.ssh/id-rsa explain：这样在~/.ssh/目录下就会生成id-rsa和id-rsa.pub的公钥和私钥。其中id-rsa 我们可以根据我们自己的需求来定义名称，例如我的名称personal-github-id-rsa(私人），company-github-id-rsa（公司github），company-gitlab-id-rsa（公司gitlab）。生成ssh-key 后我们可以copy 公钥到各git平台$ pbcopy &lt; ~/.ssh/id-rsa 通过上面的命令将公钥copy到剪贴板，然后到git平台的ssh-key页面直接粘贴即可。 2. 添加私钥$ ssh-add ~/.ssh/id-rsa 将私钥添加到我们本地ssh中# 可以通过 ssh-add -l 来确私钥列表 $ ssh-add -l # 可以通过 ssh-add -D 来清空私钥列表 $ ssh-add -D 3. 创建多账号管理文件touch ~/.ssh/config vim config # gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-gitlab-id-rsa # github Host github-company HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/company-github-id-rsa #personal-github Host github-personal HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/personal-github-rsa explain: Host 这里可以理解为我们为实际的host（如：github.com）起的别名，HostName才是实际的host address值，这样我们在本地仓库指定远程仓库的时候就可以区分出同一个平台下的不同账号体系了，可以通过下面的remote repository 地址可以看出。 4. 为本地仓库指定远程仓库地址 4.1 远程仓库地址，从github中直接复制显示： 4.2 实际为本地仓库指定远程仓库地址需要这样：添加地址：git remote add origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git 重定向地址：git remote set-url origin git@github-personal:Davidxiaoshuo/EmotionCalendar.git explain: 其中git@后面的字段为我们在config配置文件中的Host的值","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://davidxiaoshuo.github.io/tags/git/"}]},{"title":"Hello World","slug":"others/hello_world","date":"2019-04-19T07:39:43.000Z","updated":"2019-08-14T08:04:26.068Z","comments":true,"path":"others/hello_world/","link":"","permalink":"http://davidxiaoshuo.github.io/others/hello_world/","excerpt":"","text":"Hexo Page 简单发布流程Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"others","slug":"others","permalink":"http://davidxiaoshuo.github.io/tags/others/"}]}]}
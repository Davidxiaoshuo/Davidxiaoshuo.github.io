<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="author" content="David硕"><meta name="subtitle" content="write readable code"><meta name="description" content="在这个薄情的世界，深情地活着"><title>iOS 线程使用总结 1 | David硕</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script src="/js/script.js"></script><script src="/js/tocbot.min.js"></script></head><body><div class="wrapper"><header><nav class="navbar"><div class="container"><div class="navbar-header header-logo"><a href="/">David硕&#39;s Blog</a></div><div class="menu navbar-right"><a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/category">Categories</a> <a class="menu-item" href="/tag">Tags</a> <a class="menu-item" href="/about">About</a> <input id="switch_default" type="checkbox" class="switch_default"> <label for="switch_default" class="toggleBtn"></label></div></div></nav><nav class="navbar-mobile" id="nav-mobile"><div class="container"><div class="navbar-header"><div><a href="/">David硕&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a></div><div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div></div><div class="menu" id="mobile-menu"><a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/category">Categories</a> <a class="menu-item" href="/tag">Tags</a> <a class="menu-item" href="/about">About</a></div></div></nav></header><script>var mobileBtn=function(){var e=document.getElementsByClassName("menu-toggle")[0],t=document.getElementById("mobile-menu");e.classList.contains("active")?(e.classList.remove("active"),t.classList.remove("active")):(e.classList.add("active"),t.classList.add("active"))}</script><div class="main"><div class="container"><div class="post-toc"><div class="tocbot-list"></div><div class="tocbot-list-menu"><a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a> <a onclick="go_top()">Back to top</a> <a onclick="go_bottom()">Go to bottom</a></div></div><script>function expand_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:6,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","collapse_toc()"),o.innerHTML="Collapse all"}function collapse_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","expand_toc()"),o.innerHTML="Expand all"}function go_top(){window.scrollTo(0,0)}function go_bottom(){window.scrollTo(0,document.body.scrollHeight)}document.ready(function(){tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0})})</script><article class="post-wrap"><header class="post-header"><h1 class="post-title">iOS 线程使用总结 1</h1><div class="post-meta">Author: <a itemprop="author" rel="author" href="/">David硕</a> <span class="post-time">Date: <a href="#">六月 19, 2021&nbsp;&nbsp;19:15:37</a> </span><span class="post-category">Category: <a href="/categories/iOS/">iOS</a></span></div></header><div class="post-content"><blockquote><p>前言：下面出现的练习 code 在 <a href="https://github.com/Davidxiaoshuo/SwiftyThreadExercise" target="_blank" rel="noopener">SwiftyThreadExercise</a></p></blockquote><h3 id="一些基本概念"><a class="markdownIt-Anchor" href="#一些基本概念"></a> 一些基本概念</h3><ul><li>进程：在系统中运行的一个应用程序，每个进程间是独立的。每个进程均运行在其专有的且受保护的内存空间中。</li><li>线程：一个进程「程序」的所有任务都是在线程中执行的，每个进程至少有一个线程「主线程」。</li><li>主线程：一个 iOS 程序运行后，会默认开启一条线程，称之为“主线程” 或 “UI 线程”。主线程用来处理 UI 事件（如：点击，滚动，拖拽等事件），也是用来显示/刷新 UI 界面。</li><li>多线程：一个进程可以开启多条线程，多条线程可以并行「同时」执行不同的任务，多线程并发「同时」执行，其实就是 CPU 快速的在多条线程间调度「切换」。</li><li>同步：在当前线程，按照先后顺序执行，不开启新的线程。</li><li>异步：在当前线程，开启一个或多个线程，可不按照顺序执行。</li><li>队列：承载线程任务的一个容器。</li><li>并发：线程可以同时一起执行。</li><li>串行：线程执行顺序，只能按照先后顺序，依次执行。</li></ul><h3 id="ios-中线程实现方案"><a class="markdownIt-Anchor" href="#ios-中线程实现方案"></a> iOS 中线程实现方案</h3><ul><li><code>pthread</code>: 跨平台/可移植；线程生命周期需要人为管理。 <em><strong>Note: 暂不讨论, 理由：几乎用不到</strong></em></li><li><code>NSThread</code>: 使用面向对象；相比 <code>pthread</code> 更加直观操作线程对象；线程生命周期需要人为管理。</li><li><code>CCD</code>: Grand Central Dispatch, 充分利用多核，允许多任务在队列总串行或并行的执行。自动线程的生命周期。旨在替代 NSThread。</li><li><code>NSOperation</code>: 基于 <code>CGD</code>，比 GCD 多了一些实用功能；更加面向对象；线程生命周期需要人为管理。</li></ul><h4 id="nsthread"><a class="markdownIt-Anchor" href="#nsthread"></a> NSThread</h4><blockquote><p>NSThread 有以下几种状态：</p><ul><li>新建「创建」：进入就绪状态 -&gt; 运行状态。 当线程任务执行完毕，自动进入死亡状态。</li><li>就绪状态 runnable。</li><li>强制停止线程，cancel。</li><li>运行，running。</li><li>阻塞状态。</li><li>死亡状态。exit, 一旦线程停止「死亡」，就不能再次开启任务了。</li></ul></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// NSThread 启动方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动态启动，创建之后需要手动调用 start 方法</span></span><br><span class="line"><span class="keyword">let</span> thread1 = <span class="type">Thread</span>(target: <span class="keyword">self</span>, selector: #selector(onThreadRun), object: <span class="literal">nil</span>)</span><br><span class="line">thread1.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 静态启动，创建之后自动启动线程。</span></span><br><span class="line"><span class="comment">/// ①：通过 selector 方式实现</span></span><br><span class="line"><span class="type">Thread</span>.detachNewThreadSelector(#selector(onThreadRun), toTarget: <span class="keyword">self</span>, with: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ②：通过 block 方式实现</span></span><br><span class="line"><span class="type">Thread</span>.detachNewThread &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 隐式开启，`performSelector` 是 NSThread 针对 NSObject 的一个扩展方法。</span></span><br><span class="line"><span class="comment">/// ①：开启一个后台线程执行</span></span><br><span class="line"><span class="keyword">self</span>.performSelector(inBackground: #selector(onThreadRun), with: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">/// ②：在主线程执行</span></span><br><span class="line"><span class="keyword">self</span>.performSelector(onMainThread: #selector(onThreadRun), with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line"><span class="comment">/// ③：在指定线程执行</span></span><br><span class="line"><span class="keyword">self</span>.perform(#selector(onThreadRun), on: thread, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NSThread 中常用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取当前线程</span></span><br><span class="line"><span class="keyword">let</span> currentThread = <span class="type">Thread</span>.current</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取主线程</span></span><br><span class="line"><span class="keyword">let</span> mainThread= <span class="type">Thread</span>.main</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否为主线程</span></span><br><span class="line"><span class="keyword">let</span> isMainThread = <span class="type">Thread</span>.isMainThread</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线程是否在运行中</span></span><br><span class="line"><span class="type">Thread</span>.current.isExecuting</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 退出线程</span></span><br><span class="line"><span class="type">Thread</span>.exit()</span><br></pre></td></tr></table></figure><h4 id="gcd"><a class="markdownIt-Anchor" href="#gcd"></a> GCD</h4><blockquote><p>GCD 全称 Grand Central Dispatch, 其有如下优势：</p><ul><li>多核并行运算的解决方案</li><li>自动利用更多的 CPU 内核（如双核、四核）</li><li>自动管理线程的生命周期</li><li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li></ul></blockquote><p><img src="https://camo.githubusercontent.com/12f06e73fb26ab70b3caf2021ba8087e8f0186ef57190767355cd3d3ba6bfaa9/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313637383133352d343835663938643131366235373430392e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt></p><h5 id="任务-队列"><a class="markdownIt-Anchor" href="#任务-队列"></a> 任务 &amp; 队列</h5><ul><li><p>任务，就是要执行指定需求的代码块。它有两种执行方式：</p><ul><li>同步执行「sync」: 在当前线程执行任务，不会开启新的线程，必须等到任务执行完毕，dispatch 才会返回，才可以继续往下执行。</li><li>异步执行「async」： 可以在新的线程中执行任务「不一定会开启新的线程」。dispatch 会立即返回，继续往下执行，任务代码块在后台异步执行。</li></ul></li><li><p>队列，任务的管理方式。分为串行对列 &amp; 并行队列两种，都是按照 FIFO 「先进先出」原则依次触发任务。</p><ul><li>串行队列，所有任务都在同一个线程中执行，一个任务执行完毕后，才开始执行下一个任务。</li><li>并行队列，可以在多条线程执行任务，当一个任务放到指定的线程开始执行时，下一个任务就可以开始执行了。</li></ul></li><li><p>队列有以下几种类型：</p><ul><li>同步并发：没有开启新线程，串行执行任务</li><li>同步串行：没有开启新线程，串行执行任务</li><li>同步主队列：没有开启新线程，串行执行任务</li><li>异步并发：开启新线程，并发执行任务</li><li>异步串行：开启新线程，串行执行任务</li><li>异步主队列：没有开启新线程，串行执行任务</li></ul></li></ul><h5 id="特有队列"><a class="markdownIt-Anchor" href="#特有队列"></a> 特有队列</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// DispatchQueue.main 特殊串行主队列，无论是同步「sync」还是异步「async」，都是执行在主线程，async 虽然不阻塞主线程，但由于在一个队列上，DispatchQueue.main 只有在执行完当前任务后，才会执行下一个任务「async」。</span></span><br><span class="line"><span class="comment">/// Note: 一定要在主线程执行和 UI 有关的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异步主队列，串行执行任务，不阻塞当前线程</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 同步主队列，串行执行任务，阻塞当前线程。嵌套 sync &#123;&#125; ，可能会导致死锁。</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// DispatchQueue.global(), 全局并发队列, 全局只有一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异步全局队列, 串行执行任务，不阻塞当前线程</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 同步全局队列，串行执行任务，阻塞当前线程。</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().sync &#123; &#125;</span><br></pre></td></tr></table></figure><h5 id="串行队列"><a class="markdownIt-Anchor" href="#串行队列"></a> 串行队列</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 同步：</span></span><br><span class="line"><span class="comment">/// 默认即是串行队列</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"ai.studio.david.queue.1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute before, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute after, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue execute before, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 0, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 1, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 2, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 3, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 4, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 5, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 0, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 1, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 2, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 3, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 4, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 5, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue execute after, current thread = &lt;NSThread: 0x600000b6c600&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// `sync`,同步执行，阻塞当前线程。</span></span><br><span class="line"><span class="comment">/// 结果按照顺序一个一个执行，同步执行会一直等待，等一个任务执行在执行下一个任务。</span></span><br><span class="line"><span class="comment">/// 注意：主线程中的 `before` &amp; `after` 两个打印，线程信息结果跟串行队列中的是相同的。这说明，队列中的同步任务在执行时，系统给他们分配的线程是主线程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异步：</span></span><br><span class="line"><span class="comment">/// 默认即是串行队列</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"ai.studio.david.queue.1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute before, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"queue 1, index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"queue 2,index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute after, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue execute before, current thread = &lt;NSThread: 0x600003cbc540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue execute after, current thread = &lt;NSThread: 0x600003cbc540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 0, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 1, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 2, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 3, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 4, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 5, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 0, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 1, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 2, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 3, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 4, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 5, current thread = &lt;NSThread: 0x600003cb2380&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：`async`, 异步不阻塞当前线程</span></span><br><span class="line"><span class="comment">/// 由于是串行队列，任务按照 FIFO 原则，依次执行。</span></span><br><span class="line"><span class="comment">/// Note: 创建队列时的 `label` 参数，不等同于 NSThread 中的 name 属性，`label` 用于在调试工具(如Instruments、样本、stackshots和崩溃报告)中惟一地标识队列。命名风格采用反向 DNS 命名风格(com.example.myqueue)。</span></span><br></pre></td></tr></table></figure><h5 id="并发队列"><a class="markdownIt-Anchor" href="#并发队列"></a> 并发队列</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 同步，并发队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: defaultQueueLabel, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute before, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"queue 1, index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute middle, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    (<span class="number">0</span>...<span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"queue 2,index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute after, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// queue execute before, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 0, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 1, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 2, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 3, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 4, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 1, index = 5, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue execute middle, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 0, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 1, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 2, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 3, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 4, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue 2,index = 5, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// queue execute after, current thread = &lt;NSThread: 0x60000315c340&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// 并发队列执行同步任务和在主线程执行操作没有区别。`sync` 会将当前线程固定住，让当前线程等待执行完成后才能执行后面的任务。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异步，并发队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: defaultQueueLabel, attributes: .concurrent)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute before, current thread = \(Thread.current)"</span>)</span><br><span class="line">(<span class="number">0</span>..&lt;<span class="number">1000</span>).forEach &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index = \($0), current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123; <span class="built_in">print</span>(<span class="string">"task1, current thread = \(Thread.current)"</span>) &#125;</span><br><span class="line">queue.async &#123; <span class="built_in">print</span>(<span class="string">"task2, current thread = \(Thread.current)"</span>) &#125;</span><br><span class="line">queue.async &#123; <span class="built_in">print</span>(<span class="string">"task3, current thread = \(Thread.current)"</span>) &#125;</span><br><span class="line">queue.async &#123; <span class="built_in">print</span>(<span class="string">"task4, current thread = \(Thread.current)"</span>) &#125;</span><br><span class="line">queue.async &#123; <span class="built_in">print</span>(<span class="string">"task5, current thread = \(Thread.current)"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"queue execute after, current thread = \(Thread.current)"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// queue execute before, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// index = 0, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// ···</span></span><br><span class="line"><span class="comment">// index = 999, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// task1, current thread = &lt;NSThread: 0x6000002e10c0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// queue execute after, current thread = &lt;NSThread: 0x600000e80540&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// task2, current thread = &lt;NSThread: 0x6000002fc300&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// task3, current thread = &lt;NSThread: 0x6000002e02c0&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// task5, current thread = &lt;NSThread: 0x6000002e10c0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// task4, current thread = &lt;NSThread: 0x6000002a9480&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// 异步并发队列，不阻塞当前线程. 异步任务是否开启线程，根据系统资源和任务完成时间决定是否重用线程。</span></span><br><span class="line"><span class="comment">/// 虽然异步并发队列不阻塞当前线程，但是异步队列任务开始执行有可能会优先于当前线程的任务执行。</span></span><br></pre></td></tr></table></figure><h5 id="其他方法"><a class="markdownIt-Anchor" href="#其他方法"></a> 其他方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 延迟执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当前线程延迟 2s 后执行任务</span></span><br><span class="line"><span class="keyword">self</span>.perform(#selector(onDelayHandler), with: <span class="literal">nil</span>, afterDelay: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 主线程延迟 2s 后执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 全局队列延迟 2s 后执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + <span class="number">2</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过 timer 延迟 2s 后执行任务</span></span><br><span class="line"><span class="type">Timer</span>.scheduledTimer(timeInterval: <span class="number">2</span>, target: <span class="keyword">self</span>, selector: #selector(onDelayHandler), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 快速迭代遍历，阻塞当前线程，index 是无序的</span></span><br><span class="line"><span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">10</span>) &#123; index <span class="keyword">in</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="nsoperation-nsoperationqueue"><a class="markdownIt-Anchor" href="#nsoperation-nsoperationqueue"></a> NSOperation &amp; NSOperationQueue</h4><blockquote><ul><li>NSOperation &amp; NSOperationQueue 是苹果对 GCD 的封装</li><li>NSOperation &amp; NSOperationQueue 分别相当于 GCD 的任务和队列</li><li>NSOperation 是一个抽象类，可以使用其子类 <code>BlockOperation</code>, 当然也可以自定义子类</li><li>NSOperationQueue 支持 <code>暂停</code>、<code>恢复</code>、<code>取消</code>操作。这些操作，都是对后面未执行的任务进行操作，不会影响当前正在进行的任务，且 <code>取消</code> 不可以恢复。</li></ul></blockquote><h5 id="nsoperation-实现多线程步骤"><a class="markdownIt-Anchor" href="#nsoperation-实现多线程步骤"></a> NSOperation 实现多线程步骤</h5><ul><li>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。</li><li>创建队列：创建 NSOperationQueue 对象。</li><li>将操作加入到队列中：将 NSOperation 对象添加到NSOperationQueue 对象中。</li><li>之后，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</li></ul><h5 id="blockoperation-的使用"><a class="markdownIt-Anchor" href="#blockoperation-的使用"></a> BlockOperation 的使用</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> blockOperation = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1, block1, current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockOperation.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// operation1, block1, current thread = &lt;NSThread: 0x600003e303c0&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// 在仅使用 BlockOperation，不将其加入到 OperationQueue 时，block 可能会直接当前线程运行，是否开启新的线程，由系统资源决定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// BlockOperation 还提供了 addExecutionBlock 的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> blockOperation = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1, block1, current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockOperation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1, block2, current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockOperation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1, block3, current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockOperation.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// operation1, block1, current thread = &lt;NSThread: 0x6000034a0680&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// operation1, block2, current thread = &lt;NSThread: 0x6000034ad2c0&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// operation1, block5, current thread = &lt;NSThread: 0x6000034a84c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// operation1, block3, current thread = &lt;NSThread: 0x6000034fc0c0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// operation1, block4, current thread = &lt;NSThread: 0x6000034ad2c0&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// addExecutionBlock 添加的任务，是否开启新线程，由系统决定，每次执行结果可能不太一样。</span></span><br><span class="line"><span class="comment">/// 任务的执行顺序也是不确定的</span></span><br></pre></td></tr></table></figure><h5 id="nsoperation-自定义子类"><a class="markdownIt-Anchor" href="#nsoperation-自定义子类"></a> NSOperation 自定义子类</h5><blockquote><p>可以通过实现 main 方法来自定义实现一个 NSOperation 的子类。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomOperation</span>: <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> autoincrement: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> isRunning &#123;</span><br><span class="line">            <span class="keyword">if</span> isCancelled &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> autoincrement &gt;= <span class="number">100</span> &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"current value = \(autoincrement), current thread = \(Thread.current)"</span>)</span><br><span class="line">            autoincrement += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nsoperationqueue"><a class="markdownIt-Anchor" href="#nsoperationqueue"></a> NSOperationQueue</h5><p>NSOperationQueue 有两种队列形式：主队列 &amp; 自定义队列</p><ul><li>主队列：凡是添加到主队列中的操作，都会放到主线程中执行</li><li>自定义队列：操作自动放到子线程中执行，同时包含了：串行、并发功能。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainQueue = <span class="type">OperationQueue</span>.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customQueue = <span class="type">OperationQueue</span>()</span><br></pre></td></tr></table></figure><p>添加任务到队列中</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">OperationQueue</span>()</span><br><span class="line"><span class="comment">/// 最大并发数，它有默认最大并发，其值根据当前系统换件决定。</span></span><br><span class="line"><span class="comment">/// 当 maxConcurrentOperationCount = 1 时，是串行，</span></span><br><span class="line">operationQueue.maxConcurrentOperationCount = <span class="type">OperationQueue</span>.defaultMaxConcurrentOperationCount</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> blockOperation = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1, block1, current thread = \(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operationQueue.addOperation(blockOperation)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：</span></span><br><span class="line"><span class="comment">/// 将 BlockOperation 添加到 OperationQueue 中后，系统将不在当前线程执行，而是开启新的线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过 addDependency 设置依赖关系，保证执行顺序</span></span><br><span class="line">blockOperation.addDependency(blockOperation2)</span><br><span class="line">operationQueue.addOperation(blockOperation)</span><br><span class="line">operationQueue.addOperation(blockOperation2)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 分析：先执行 blockOperation2，再执行 blockOperation</span></span><br></pre></td></tr></table></figure></div><section class="post-copyright"><p class="copyright-item"><span>Author:</span> <span>David硕</span></p><p class="copyright-item"><span>Permalink:</span> <span><a href="http://davidxiaoshuo.github.io/iOS/thread_summary_1/">http://davidxiaoshuo.github.io/iOS/thread_summary_1/</a></span></p><p class="copyright-item"><span>License:</span> <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span></p><p class="copyright-item"><span>Slogan:</span> <span>Write readable code!</span></p></section><section class="post-tags"><div><span>Tag(s):</span> <span class="tag"><a href="/tags/swift，Objective-C/"># swift，Objective-C</a></span></div><div><a href="javascript:window.history.back();">back</a> <span>· </span><a href="/">home</a></div></section><section class="post-nav"><a class="prev" rel="prev" href="/iOS/runtime/">iOS Runtime 上手 -</a> <a class="next" rel="next" href="/iOS/swift_dynamic/">Swift 静态 vs 动态 分派</a></section></article></div></div><footer id="footer" class="footer"><div class="copyright"><span>© David硕 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span></div></footer></div></body></html>